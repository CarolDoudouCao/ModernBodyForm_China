---
title: "Modern_Chinese_bodysize_proportion_z_transformed"
author: "DC"
date: "2025-04-03"
output: html_document
---
# Install packages
```{r, warning=FALSE}
options(repos = c(CRAN = "https://cloud.r-project.org"))

required_packages <- c("tidyverse", "sf", "raster", "ggmap", "ggbreak", "bayesplot", "tidybayes","ggridges", "patchwork","sp", "akima", 
                       "rnaturalearth", "car", "MASS", "sandwich", "lmtest", 
                       "scales", "gstat", "lmerTest", "brms", "RColorBrewer", 
                       "here", "viridis", "loo")

# Install missing packages
install_missing <- required_packages[!required_packages %in% installed.packages()[, "Package"]]
if (length(install_missing) > 0) {
  install.packages(install_missing)
}

# Load packages quietly
invisible(lapply(required_packages, function(pkg) suppressMessages(library(pkg, character.only = TRUE))))

```

# Prepare the data

```{r,warning=FALSE}
# Load data
groups <- read.csv("modern_multiple_groups.csv", stringsAsFactors = FALSE)

# Convert relevant columns to numeric
num_cols <- c("Stature", "Bodymass", "RSittinght", "RelativeBodyBreadth", "Longitude", "Latitude")
groups[num_cols] <- lapply(groups[num_cols], function(x) as.numeric(replace(x, x == "-", NA)))

# Remove rows with missing coordinates
groups <- groups %>% drop_na(Longitude, Latitude)

# Extract coordinates
coordinates <- groups %>% dplyr::select(Longitude, Latitude)

# Convert to spatial points
points <- SpatialPoints(coordinates)

# Load raster layers
climate_paths <- list(
  Mintemp   = "climatic data/wc2.1_30s_bio/wc2.1_30s_bio_6.tif",
  Maxtemp   = "climatic data/wc2.1_30s_bio/wc2.1_30s_bio_5.tif",
  Minprecip = "climatic data/wc2.1_30s_bio/wc2.1_30s_bio_14.tif",
  Maxprecip = "climatic data/wc2.1_30s_bio/wc2.1_30s_bio_13.tif",
  Altitude  = "climatic data/wc2.1_30s_elev.tif"
)
Mintemp_raster   <- raster("climatic data/wc2.1_30s_bio/wc2.1_30s_bio_6.tif")
Maxtemp_raster   <- raster("climatic data/wc2.1_30s_bio/wc2.1_30s_bio_5.tif")
Minprecip_raster <- raster("climatic data/wc2.1_30s_bio/wc2.1_30s_bio_14.tif")
Maxprecip_raster <- raster("climatic data/wc2.1_30s_bio/wc2.1_30s_bio_13.tif")
Altitude_raster  <- raster("climatic data/wc2.1_30s_elev.tif")

# Extract raster values
climate_data <- lapply(climate_paths, function(path) extract(raster(path), points))

# Add extracted climate variables to the dataset
groups <- bind_cols(groups, as.data.frame(climate_data))

# Keep only rows with complete climate data
groups <- groups %>% drop_na(Mintemp, Maxtemp, Minprecip, Maxprecip, Altitude)

# Keep groups with at least 3 individuals
groups <- groups %>% group_by(Langsubgroup) %>% filter(n() >= 3) %>% ungroup()

# Split data by sex
male_data   <- filter(groups, Sex == "M")
female_data <- filter(groups, Sex == "F")
```

# Set Mapping Parameters
```{r}
# Ensure SHX file restoration
Sys.setenv("SHAPE_RESTORE_SHX" = "YES")

# Load shapefile
chinashape <- st_read("bou1_4p.shp")
basemap_wgs84 <- st_transform(chinashape, crs = 4326)
basemap_sp_wgs84 <- as_Spatial(basemap_wgs84)


male_colors_z <- rev(brewer.pal(9, "RdBu"))
female_colors_z <- rev(brewer.pal(9, "PuOr"))

z_limits <- c(-2.1,2.1)

# Save scaling parameters for longitude and latitude
# Save scaling parameters for males
male_longitude_center <- attr(scale(male_data$Longitude), "scaled:center")
male_longitude_scale  <- attr(scale(male_data$Longitude), "scaled:scale")
male_latitude_center  <- attr(scale(male_data$Latitude), "scaled:center")
male_latitude_scale   <- attr(scale(male_data$Latitude), "scaled:scale")
male_mintemp_center   <- attr(scale(male_data$Mintemp), "scaled:center")
male_mintemp_scale    <- attr(scale(male_data$Mintemp), "scaled:scale")
male_maxtemp_center   <- attr(scale(male_data$Maxtemp), "scaled:center")
male_maxtemp_scale    <- attr(scale(male_data$Maxtemp), "scaled:scale")
male_minprecip_center <- attr(scale(male_data$Minprecip), "scaled:center")
male_minprecip_scale  <- attr(scale(male_data$Minprecip), "scaled:scale")
male_maxprecip_center <- attr(scale(male_data$Maxprecip), "scaled:center")
male_maxprecip_scale  <- attr(scale(male_data$Maxprecip), "scaled:scale")
male_altitude_center  <- attr(scale(male_data$Altitude), "scaled:center")
male_altitude_scale   <- attr(scale(male_data$Altitude), "scaled:scale")

# Save scaling parameters for females
female_longitude_center <- attr(scale(female_data$Longitude), "scaled:center")
female_longitude_scale  <- attr(scale(female_data$Longitude), "scaled:scale")
female_latitude_center  <- attr(scale(female_data$Latitude), "scaled:center")
female_latitude_scale   <- attr(scale(female_data$Latitude), "scaled:scale")
female_mintemp_center   <- attr(scale(female_data$Mintemp), "scaled:center")
female_mintemp_scale    <- attr(scale(female_data$Mintemp), "scaled:scale")
female_maxtemp_center   <- attr(scale(female_data$Maxtemp), "scaled:center")
female_maxtemp_scale    <- attr(scale(female_data$Maxtemp), "scaled:scale")
female_minprecip_center <- attr(scale(female_data$Minprecip), "scaled:center")
female_minprecip_scale  <- attr(scale(female_data$Minprecip), "scaled:scale")
female_maxprecip_center <- attr(scale(female_data$Maxprecip), "scaled:center")
female_maxprecip_scale  <- attr(scale(female_data$Maxprecip), "scaled:scale")
female_altitude_center  <- attr(scale(female_data$Altitude), "scaled:center")
female_altitude_scale   <- attr(scale(female_data$Altitude), "scaled:scale")
```

# Male_stature
## Create the processed dataset with scaled predictors
```{r}
modern_male_stature <- male_data %>%
  filter(!is.na(Stature)) %>%    # Keep non-missing Stature values
  mutate(
    longitude_scaled   = as.numeric(scale(Longitude)[,1]),  # Scale Longitude
    latitude_scaled    = as.numeric(scale(Latitude)[,1]),   # Scale Latitude
    mintemp_scaled     = as.numeric(scale(Mintemp)[,1]),    # Scale Minimum Temperature
    maxtemp_scaled     = as.numeric(scale(Maxtemp)[,1]),    # Scale Maximum Temperature
    minprecip_scaled   = as.numeric(scale(Minprecip)[,1]),  # Scale Minimum Precipitation
    maxprecip_scaled   = as.numeric(scale(Maxprecip)[,1]),  # Scale Maximum Precipitation
    altitude_scaled    = as.numeric(scale(Altitude)[,1]),   # Scale Altitude
    stature_z          = as.numeric(scale(Stature)[,1])     # Scale Stature (response variable)
  )
sd(modern_male_stature$Stature)
```

## Define the model formula
```{r}
# - Predict stature_z using:
#     - a smooth spatial term (longitude × latitude interaction)
#     - Time period and Urbanism
#     - Climatic predictors (scaled)
#     - Random intercepts and slopes for Time by Langsubgroup
male_stature_formula_z <- bf(
  stature_z ~ t2(longitude_scaled, latitude_scaled) + 
    Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + 
    minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)
```

## Fit the model 
```{r}
# - Student's t likelihood for robustness against outliers
# - Weakly informative priors to regularize estimates
# - Save all posterior draws for later use (save_pars)
fit_modern_male_stature_z <- brm(
  formula = male_stature_formula_z,
  data = modern_male_stature,
  family = student(),  # Student-t distribution
  prior = c(
    prior(normal(0, 1), class = Intercept),           # Prior for Intercept
    prior(normal(0, 1), class = b),                   # Prior for fixed effects
    prior(cauchy(0, 1), class = sigma),               # Prior for residual error
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"), # Prior for random effects
    prior(gamma(2, 0.2), class = nu)                  # Prior for Student-t degrees of freedom
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,  # MCMC settings
  control = list(adapt_delta = 0.99),                 # Increase adapt_delta for better convergence
  save_pars = save_pars(all = TRUE)                   # Save full posterior for future use
)

# Display model summary
summary(fit_modern_male_stature_z)
```

##  Posterior Extraction 
```{r, warning=FALSE}
# Extract posterior draws as a data frame:
post_draws_male_stature_z <- as_draws_df(fit_modern_male_stature_z)

# Extract fixed effects (parameters starting with "b_")
fixef_male_stature_z <- post_draws_male_stature_z[, grepl("^b_", colnames(post_draws_male_stature_z))]

# Remove the intercept parameter
fixef_male_stature_no_int <- fixef_male_stature_z[, !grepl("Intercept", colnames(fixef_male_stature_z))]

# Extract random effects (e.g., for Langsubgroup)
raneff_male_stature_z <- post_draws_male_stature_z[, grepl("^r_Langsubgroup", colnames(post_draws_male_stature_z))]
```

### Fixed effects density plots (excluding intercept) 

```{r}
# 1) helper to clean up names
clean_labels <- function(x) {
  x %>%
    str_remove("^b_") %>%          # drop 'b_' prefix
    str_remove("^Urbanism") %>%    # drop 'Urbanism' if it’s at the start
    str_remove("_scaled$") %>%     # drop '_scaled' suffix
    str_to_sentence()              # capitalize first letter
}

# 2) compute means
fixed_male_stature_z <- colnames(fixef_male_stature_no_int)
means_male_stature_z <- apply(fixef_male_stature_no_int, 2, mean)
means_male_stature_df_z <- data.frame(
  parameter = fixed_male_stature_z,
  mean      = means_male_stature_z,
  stringsAsFactors = FALSE
)

# 3) clean the column names *and* the means labels
colnames(fixef_male_stature_no_int) <- clean_labels(colnames(fixef_male_stature_no_int))
means_male_stature_df_z$parameter   <- clean_labels(means_male_stature_df_z$parameter)

# 4) plot
p_fixed_male_stature_z <- mcmc_areas_ridges(
  fixef_male_stature_no_int,
  regex_pars = ".*",    # now match every cleaned name
  prob       = 0.95
) +
  labs(
    title = "Male Stature",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8) +
  geom_point(
    data     = means_male_stature_df_z,
    aes(x = mean, y = parameter),
    shape    = 124, size = 3, color = "blue",
    position = position_nudge(y = 0.5)
  )

# display
p_fixed_male_stature_z

```


```{r}
ggsave(filename = "output/male_stature_z_fixed_effects.tiff", 
       plot = p_fixed_male_stature_z, 
       dpi = 300, 
       device = "tiff",
       width = 12, height = 6, units = "in")
```

### Random effects density plot
```{r}
clean_random_labels <- function(x) {
  x %>%
    sub("^r_Langsubgroup\\[", "", .) %>%  # drop opening
    sub("\\]$", "", .)  %>%  
    sub(",Intercept$", "", .) %>% 
    sub(",TimeLate$", "", .) # drop closing
}
random_intercept_male_stature_z <- grep("Intercept", colnames(raneff_male_stature_z), value = TRUE)
random_slope_male_stature_z     <- grep("TimeLate", colnames(raneff_male_stature_z), value = TRUE)
random_slope_male_stature_z <- random_slope_male_stature_z[
  !grepl("Austronesian", random_slope_male_stature_z)
]
# Plot for random intercepts
## visualizing for each language subgroup whether its baseline stature (at average longitude/latitude, the “Early” period, average climate, etc.) sits above or below the grand mean.
p_random_intercepts_male_stature_z <- mcmc_areas(
  raneff_male_stature_z,
  pars = random_intercept_male_stature_z,
  prob = 0.95  # 95% confidence intervals
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(
    x = "Random Intercept: Baseline Deviation (Male Stature Z)"
  ) +
  theme_minimal(base_size = 12) +
  # Mark zero with a vertical dashed red line using linewidth instead of size
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# Plot for random slopes for Time
# Random slope r_Langsubgroup[<group>,TimeLate] is each subgroup’s deviation from that average Late–Early effect.
p_random_slopes_male_stature_z <- mcmc_areas(
  raneff_male_stature_z,
  pars = random_slope_male_stature_z,
  prob = 0.95
) +  
  scale_y_discrete(labels = clean_random_labels) +
  labs(
    x = "Random Slope: Late vs Early Period (Male Stature Z)"
  ) +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)
print(p_random_intercepts_male_stature_z)
print(p_random_slopes_male_stature_z)

# 5b) Or arrange side‑by‑side:
(p_random_intercepts_male_stature_z | p_random_slopes_male_stature_z) +
  plot_layout(ncol = 2, widths = c(1, 1)) &
  theme(plot.margin = margin(5, 5, 5, 5))


```


```{r}
# Save individual plots if desired:
ggsave(filename = "output/male_stature_z_random_intercepts.tiff", 
       plot = p_random_intercepts_male_stature_z, 
       dpi = 300, 
       device = "tiff",
       width = 10, height = 6, units = "in")

ggsave(filename = "output/male_stature_z_random_slopes.tiff", 
       plot = p_random_slopes_male_stature_z, 
       dpi = 300, 
       device = "tiff",
       width = 10, height = 6, units = "in")
```

## Male_stature_prediction (Early Rural)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude for mapping.
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks.
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# Predict over spatial grid using correct model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict from model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_stature_z,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Stature_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  rm(grid_chunk)
  gc()
}

# Combine and save
final_predictions_male_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_z,
  file = here("output", "final_male_stature_predictions_20chunks_z_early_rural.csv"),
  row.names = FALSE
)

cat("Grid prediction complete and saved.\n")
```

## Male_stature_prediction (Late Urban)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude for mapping.
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks.
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# Predict over spatial grid using correct model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict from model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_stature_z,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Stature_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  rm(grid_chunk)
  gc()
}

# Combine and save
final_predictions_male_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_z,
  file = here("output", "final_male_stature_predictions_20chunks_z_late_urban.csv"),
  row.names = FALSE
)

cat("Grid prediction complete and saved.\n")
```


### Predict male_stature_coordonly (Early Rural)
```{r}
# Create geographic grid (if not done already)
grid_male_stature_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split into chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_stature_coordonly, 
                          cut(seq_len(nrow(grid_male_stature_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale coordinates
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude  - male_latitude_center)  / male_latitude_scale,
      
      # Neutral values for env predictors
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict from full model (spatial-only, env = 0)
  chunk_pred <- predict(
     fit_modern_male_stature_z,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$Stature_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}
df_male_stature_coordonly_z <- do.call(rbind, predictions_coordonly_list)

# Save if you like
write.csv(df_male_stature_coordonly_z,
          here("output", "male_stature_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction complete!\n")
```

### Predict male_stature_coordonly (Late Urban)
```{r}
# Create geographic grid (if not done already)
grid_male_stature_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split into chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_stature_coordonly, 
                          cut(seq_len(nrow(grid_male_stature_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale coordinates
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude  - male_latitude_center)  / male_latitude_scale,
      
      # Neutral values for env predictors
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict from full model (spatial-only, env = 0)
  chunk_pred <- predict(
    fit_modern_male_stature_z,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$Stature_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}
df_male_stature_coordonly_z <- do.call(rbind, predictions_coordonly_list)

# Save if you like
write.csv(df_male_stature_coordonly_z,
          here("output", "male_stature_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction complete!\n")
```

###--------Early Rural-----------------
### Visual full-Early Rural
```{r}
# Read the predicted male stature CSV (with z-scored predictions)
extended_grid_male_stature <- read.csv(here("output", "final_male_stature_predictions_20chunks_z_with_coordinates_early_rural.csv"))

# Average the z-scored predictions across all Time and Urbanism to capture overall spatial trends
spatial_trends_male_stature <- extended_grid_male_stature %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Stature_z = mean(Stature_pred_z, na.rm = TRUE)
  ) %>%
  ungroup()

# Create a raster from the averaged z-scored predictions (using Longitude, Latitude, and Stature_z)
rast_z_male_stature <- rasterFromXYZ(spatial_trends_male_stature[, c("Longitude", "Latitude", "Stature_z")])

# Mask the raster with the basemap (basemap_sp_wgs84 should be an sf or Spatial* object)
rast_z_masked_male_stature <- mask(rast_z_male_stature, basemap_sp_wgs84)
crs(rast_z_masked_male_stature) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for plotting
spatial_trends_z_male_stature <- as.data.frame(rasterToPoints(rast_z_masked_male_stature), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_stature) <- c("Longitude", "Latitude", "Stature_z")


# Create the ggplot for spatial trends (predicted z-scores)
p_spatial_male_stature_trends_z <- ggplot(spatial_trends_z_male_stature, 
                              aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), 
          inherit.aes = FALSE, 
          color = "darkgray", 
          linewidth = 1) +
  # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  scale_fill_gradientn(
    colors = male_colors_z,          # custom color palette
    limits = z_limits,       # predefined or calculated limits
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Stature (Z-Scored)",
    x = "Longitude", 
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Show and save the plot
print(p_spatial_male_stature_trends_z)
```

### Coordinates only visual (early rural)
```{r, warning=FALSE}
# Read prediction from coordinate-only chunks (z-scored)
df_male_stature_coordonly_z <- read.csv(here("output", "male_stature_pred_coordonly_chunks_z_early_rural.csv"))

# Optional check
head(df_male_stature_coordonly_z)
# Rename just in case
colnames(df_male_stature_coordonly_z)[colnames(df_male_stature_coordonly_z) == "Stature_pred_z"] <- "Stature_z"
# Convert to raster
rast_male_stature_coordonly_z <- rasterFromXYZ(
  df_male_stature_coordonly_z[, c("Longitude", "Latitude", "Stature_z")]
)

# Mask using shapefile
rast_male_stature_coordonly_z <- mask(rast_male_stature_coordonly_z, basemap_sp_wgs84)
crs(rast_male_stature_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")
df_male_stature_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_stature_coordonly_z),
  stringsAsFactors = FALSE
)

colnames(df_male_stature_coordonly_z_plot) <- c("Longitude", "Latitude", "Stature_z")
plot_male_stature_coordonly_z_early_rural <- ggplot(df_male_stature_coordonly_z_plot, 
                                        aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), 
          inherit.aes = FALSE,  
          color = "darkgray", 
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Stature (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
plot_male_stature_coordonly_z_early_rural
```


### Comparing "Full model" vs "Coordinate-only" prediction (Early_rural)
```{r,warning=FALSE}
# Merge full prediction and coordinate-only prediction
comparison_male_stature_z <- extended_grid_male_stature %>%
 dplyr::select(Longitude, Latitude, Stature_z_full = Stature_pred_z) %>%
  inner_join(
    df_male_stature_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Stature_z_coordonly = Stature_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Stature_z_full - Stature_z_coordonly
  )
comparison_male_stature_z <- comparison_male_stature_z %>%
  filter(!is.na(Stature_z_full) & !is.na(Stature_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_male_stature   <- rasterFromXYZ(comparison_male_stature_z[, c("Longitude","Latitude","Stature_z_full")])
r_coord_male_stature  <- rasterFromXYZ(comparison_male_stature_z[, c("Longitude","Latitude","Stature_z_coordonly")])
r_env_male_stature    <- rasterFromXYZ(comparison_male_stature_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_stature <- stack(r_full_male_stature, r_coord_male_stature, r_env_male_stature)
names(r_stack_male_stature) <- c("Stature_z_full","Stature_z_coordonly","Env_effect")
r_stack_masked_male_stature <- mask(r_stack_male_stature, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_stature <- as.data.frame(rasterToPoints(r_stack_masked_male_stature)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_stature_z_masked <- df_masked_male_stature %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_stature_long_z_masked <- comparison_male_stature_z_masked %>%
  pivot_longer(c(Stature_z_full, Stature_z_coordonly, Env_effect),
               names_to="Model", values_to="Stature_z") %>%
  mutate(Model = factor(Model,
    levels = c("Stature_z_full","Stature_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_male_stature_comparison_z_early_rural <- ggplot(comparison_male_stature_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
     # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
     scale_x_continuous(
      breaks = seq(70, 140, by = 20))+
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_text(size = 7, face = "bold"),
    plot.title = element_text(size = 7, face = "bold"),
    axis.title = element_text(size = 7),
    axis.text = element_text(size = 7),
    legend.title = element_text(size = 7),
    legend.text = element_text(size = 7)
  )

p_male_stature_comparison_z_early_rural
```

###--------Late Urban-----------------
### Visual full- late urban
```{r}
# Read the predicted male stature CSV (with z-scored predictions)
extended_grid_male_stature <- read.csv(here("output", "final_male_stature_predictions_20chunks_z_late_urban.csv"))

# Average the z-scored predictions across all Time and Urbanism to capture overall spatial trends
spatial_trends_male_stature <- extended_grid_male_stature %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Stature_z = mean(Stature_pred_z, na.rm = TRUE)
  ) %>%
  ungroup()

# Create a raster from the averaged z-scored predictions (using Longitude, Latitude, and Stature_z)
rast_z_male_stature <- rasterFromXYZ(spatial_trends_male_stature[, c("Longitude", "Latitude", "Stature_z")])

# Mask the raster with the basemap (basemap_sp_wgs84 should be an sf or Spatial* object)
rast_z_masked_male_stature <- mask(rast_z_male_stature, basemap_sp_wgs84)
crs(rast_z_masked_male_stature) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for plotting
spatial_trends_z_male_stature <- as.data.frame(rasterToPoints(rast_z_masked_male_stature), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_stature) <- c("Longitude", "Latitude", "Stature_z")
# Create the ggplot for spatial trends (predicted z-scores)
p_spatial_male_stature_trends_z_late_urban <- ggplot(spatial_trends_z_male_stature, 
                              aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), 
          inherit.aes = FALSE, 
          color = "darkgray", 
          linewidth = 1) +
  # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  scale_fill_gradientn(
    colors = male_colors_z,          # custom color palette
    limits = z_limits,       # predefined or calculated limits
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Stature (Z-Scored)",
    x = "Longitude", 
    y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Show and save the plot
print(p_spatial_male_stature_trends_z_late_urban)
```

### Coordinates only visual (late_urban)
```{r, warning=FALSE}
# Read prediction from coordinate-only chunks (z-scored)
df_male_stature_coordonly_z <- read.csv(here("output", "male_stature_pred_coordonly_chunks_z_late_urban.csv"))

# Optional check
head(df_male_stature_coordonly_z)
# Rename just in case
colnames(df_male_stature_coordonly_z)[colnames(df_male_stature_coordonly_z) == "Stature_pred_z"] <- "Stature_z"
# Convert to raster
rast_male_stature_coordonly_z <- rasterFromXYZ(
  df_male_stature_coordonly_z[, c("Longitude", "Latitude", "Stature_z")]
)

# Mask using shapefile
rast_male_stature_coordonly_z <- mask(rast_male_stature_coordonly_z, basemap_sp_wgs84)
crs(rast_male_stature_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")
df_male_stature_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_stature_coordonly_z),
  stringsAsFactors = FALSE
)

colnames(df_male_stature_coordonly_z_plot) <- c("Longitude", "Latitude", "Stature_z")
plot_male_stature_coordonly_z_late_urban <- ggplot(df_male_stature_coordonly_z_plot, 
                                        aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), 
          inherit.aes = FALSE,  
          color = "darkgray", 
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Stature (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
plot_male_stature_coordonly_z_late_urban
```

### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r, warning=FALSE}
# Merge full prediction and coordinate-only prediction
comparison_male_stature_z <- extended_grid_male_stature %>%
 dplyr::select(Longitude, Latitude, Stature_z_full = Stature_pred_z) %>%
  inner_join(
    df_male_stature_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Stature_z_coordonly = Stature_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Stature_z_full - Stature_z_coordonly
  )
comparison_male_stature_z <- comparison_male_stature_z %>%
  filter(!is.na(Stature_z_full) & !is.na(Stature_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_male_stature   <- rasterFromXYZ(comparison_male_stature_z[, c("Longitude","Latitude","Stature_z_full")])
r_coord_male_stature  <- rasterFromXYZ(comparison_male_stature_z[, c("Longitude","Latitude","Stature_z_coordonly")])
r_env_male_stature    <- rasterFromXYZ(comparison_male_stature_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_stature <- stack(r_full_male_stature, r_coord_male_stature, r_env_male_stature)
names(r_stack_male_stature) <- c("Stature_z_full","Stature_z_coordonly","Env_effect")
r_stack_masked_male_stature <- mask(r_stack_male_stature, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_stature <- as.data.frame(rasterToPoints(r_stack_masked_male_stature)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_stature_z_masked <- df_masked_male_stature %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_stature_long_z_masked <- comparison_male_stature_z_masked %>%
  pivot_longer(c(Stature_z_full, Stature_z_coordonly, Env_effect),
               names_to="Model", values_to="Stature_z") %>%
  mutate(Model = factor(Model,
    levels = c("Stature_z_full","Stature_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_male_stature_comparison_z_late_urban <- ggplot(comparison_male_stature_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
     # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
     scale_x_continuous(
      breaks = seq(70, 140, by = 20))+
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_text(size = 7, face = "bold"),
    plot.title = element_text(size = 7, face = "bold"),
    axis.title = element_text(size = 7),
    axis.text = element_text(size = 7),
    legend.title = element_text(size =7),
    legend.text = element_text(size = 7)
  )

p_male_stature_comparison_z_late_urban
```



#### take only the Env_effect panel
```{r, warning=FALSE}
env_df_male_stature <- comparison_male_stature_long_z_masked %>%
  filter(Model == "C) Environmental Effect (Full–Coordonly)")

# plot just that
p_env_male_stature <- ggplot(env_df_male_stature, aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "Male stature\n(z-score)",
    na.value = "transparent"
  ) +
  geom_point(data = modern_male_stature, 
             aes(x = Longitude, y = Latitude),
             size = 0.3, shape = 24, fill = "red", color = "red", stroke = 0.1) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "C) Environmental Effect (Full – Coordonly)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal(base_size = 8) +
  theme(
    plot.title   = element_text(size = 8, face = "bold"),
    axis.title   = element_text(size = 7),
    axis.text    = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.text  = element_text(size = 6)
  )

p_env_male_stature
```

#### Highlighting environmental effets
```{r}
p_env_effect_masked_male_stature <- ggplot(comparison_male_stature_z_masked, 
                              aes(x = Longitude, y = Latitude)) +
  geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
  geom_raster(data = subset(comparison_male_stature_z_masked, Env_effect_category == "Weak"), 
              fill = "grey90") +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "Environmental\nEffect (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
       # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "D) Environmental Effect (Masked by Strength)",
    subtitle = "Gray = Weak Effect (|z| < 0.3)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    plot.title = element_text(size = 6, face = "bold"),
    plot.subtitle = element_text(size = 6),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_env_effect_masked_male_stature
```


```{r, warning=FALSE}
for (threshold in c(0.1, 0.3, 0.5)) {
  cat("Threshold:", threshold, "\n")
  
  tmp_df <- comparison_male_stature_z_masked %>%
    mutate(Env_effect_category = if_else(abs(Env_effect) >= threshold, "Strong", "Weak"))
  
  p_tmp <- ggplot(tmp_df, aes(x = Longitude, y = Latitude)) +
    geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
    geom_raster(data = subset(tmp_df, Env_effect_category == "Weak"),
                fill = "grey90") +
    scale_fill_gradientn(
      colors = male_colors_z, limits = z_limits, na.value = "transparent",
      name = "Environmental\nEffect (z-score)"
    ) +
     # Add original sites as points
  geom_point(data = modern_male_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    ggtitle(paste0("Environmental Effect (Threshold ", threshold, ")")) +
    theme_minimal()
  
  print(p_tmp)
}
```



###Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_male_stature <- conditional_effects(fit_modern_male_stature_z, effects = "altitude_scaled")
p_altitude_male_stature <- plot(ce_altitude_male_stature, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_male_stature <- min(modern_male_stature$altitude_scaled, na.rm = TRUE)
altitude_max_male_stature <- max(modern_male_stature$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_male_stature <- p_altitude_male_stature +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.58, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.58, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_male_stature$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  # —— bottom-only “ticks” using geom_jitter() ——  
  geom_jitter(
    data     = modern_male_stature,
    mapping  = aes(x = altitude_scaled, y = -Inf), # anchor at bottom
    inherit.aes = FALSE,
    shape    = 124,                               # vertical bar “|”
    size     = 3,                                 # thickness of the tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show

  # Range markers
  geom_vline(xintercept = altitude_min_male_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_male_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_male_stature, y = Inf, 
           label = paste("Min =", round(altitude_min_male_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_male_stature, y = Inf, 
           label = paste("Max =", round(altitude_max_male_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Stature (Z-score)"
  )

print(p_altitude_jitter_ticks_male_stature)

modern_male_stature %>%
  filter(altitude_scaled > 1.58)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_male_stature <- conditional_effects(fit_modern_male_stature_z, effects = "mintemp_scaled")
p_mintemp_male_stature <- plot(ce_mintemp_male_stature, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_male_stature <- min(modern_male_stature$mintemp_scaled, na.rm = TRUE)
temp_max_male_stature <- max(modern_male_stature$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_male_stature <- p_mintemp_male_stature +
  geom_jitter(
    data     = modern_male_stature,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"     
  )  +
  geom_vline(xintercept = temp_min_male_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_male_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_male_stature, y = Inf, label = paste("Min =", round(temp_min_male_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_male_stature, y = Inf, label = paste("Max =", round(temp_max_male_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Stature (z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_mintemp_updated_male_stature)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r,warning=FALSE}
ce_maxtemp_male_stature <- conditional_effects(fit_modern_male_stature_z, effects = "maxtemp_scaled")
p_maxtemp_male_stature <- plot(ce_maxtemp_male_stature, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_male_stature <- min(modern_male_stature$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_male_stature <- max(modern_male_stature$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_male_stature <- p_maxtemp_male_stature +
  geom_jitter(
    data = modern_male_stature,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxtemp_min_male_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_male_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_male_stature, y = Inf, label = paste("Min =", round(maxtemp_min_male_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_male_stature, y = Inf, label = paste("Max =", round(maxtemp_max_male_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Stature (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxtemp_updated_male_stature)
```


####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_male_stature <- conditional_effects(fit_modern_male_stature_z, effects = "minprecip_scaled")
p_minprecip_male_stature <- plot(ce_minprecip_male_stature, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_male_stature <- min(modern_male_stature$minprecip_scaled, na.rm = TRUE)
minprecip_max_male_stature <- max(modern_male_stature$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_male_stature <- p_minprecip_male_stature +
  geom_jitter(
    data = modern_male_stature,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = minprecip_min_male_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_male_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_male_stature, y = Inf, label = paste("Min =", round(minprecip_min_male_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_male_stature, y = Inf, label = paste("Max =", round(minprecip_max_male_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Stature (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible
print(p_minprecip_updated_male_stature)
```
#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r}
ce_maxprecip_male_stature <- conditional_effects(fit_modern_male_stature_z, effects = "maxprecip_scaled")
p_maxprecip_male_stature <- plot(ce_maxprecip_male_stature, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_male_stature <- min(modern_male_stature$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_male_stature <- max(modern_male_stature$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_male_stature <- p_maxprecip_male_stature +
  geom_jitter(
    data = modern_male_stature,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxprecip_min_male_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_male_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_male_stature, y = Inf, label = paste("Min =", round(maxprecip_min_male_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_male_stature, y = Inf, label = paste("Max =", round(maxprecip_max_male_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Stature (Z-score)"
  )+
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxprecip_updated_male_stature)
```

#### Check the extereme cases
```{r}
modern_male_stature %>%
  filter(mintemp_scaled > 1.5)
modern_male_stature %>%
  filter(mintemp_scaled < - 2)
modern_male_stature %>%
  filter(maxtemp_scaled > 1)
modern_male_stature %>%
  filter(maxtemp_scaled < - 3)
modern_male_stature %>%
  filter(minprecip_scaled > 3)
modern_male_stature %>%
  filter(minprecip_scaled < 0)
modern_male_stature %>%
  filter(maxprecip_scaled > 3)
modern_male_stature %>%
  filter(maxprecip_scaled < -1)
```


# Male Body mass
```{r}
# Male Body mass
modern_male_bodymass <- male_data %>%
  filter(!is.na(Bodymass)) %>%
             mutate(
                            Bodymass   = as.numeric(Bodymass),
                                longitude_scaled  = as.numeric(scale(Longitude)[,1]),
                                latitude_scaled   = as.numeric(scale(Latitude)[,1]),
                                    mintemp_scaled    = as.numeric(scale(Mintemp)[,1]),
                                    maxtemp_scaled    = as.numeric(scale(Maxtemp)[,1]),
                                    minprecip_scaled  = as.numeric(scale(Minprecip)[,1]),
                                    maxprecip_scaled  = as.numeric(scale(Maxprecip)[,1]),
                                    altitude_scaled  = as.numeric(scale(Altitude)[,1]),
                                    Bodymass_z        = as.numeric(scale(Bodymass)[,1])
                                         )

mean(modern_male_bodymass$Bodymass, na.rm = TRUE)
sd(modern_male_bodymass$Bodymass, na.rm = TRUE)
mean(modern_male_bodymass$Altitude, na.rm = TRUE)
sd(modern_male_bodymass$Altitude, na.rm = TRUE)
```

```{r}
male_bodymass_formula_scaled <- bf(
  Bodymass_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_male_bodymass_scaled <- brm(
  formula = male_bodymass_formula_scaled,
  data = modern_male_bodymass,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

summary(fit_modern_male_bodymass_scaled)
```

## Extract posterior draws
```{r}
# Extract posterior draws
post_draws_male_bodymass_z <- as_draws_df(fit_modern_male_bodymass_scaled)

# Extract fixed effects (parameters starting with "b_")
fixef_male_bodymass_z <- post_draws_male_bodymass_z[, grepl("^b_", colnames(post_draws_male_bodymass_z))]

# Remove intercept
fixef_male_bodymass_no_int <- fixef_male_bodymass_z[, !grepl("Intercept", colnames(fixef_male_bodymass_z))]

# Extract random effects
raneff_male_bodymass_z <- post_draws_male_bodymass_z[, grepl("^r_Langsubgroup", colnames(post_draws_male_bodymass_z))]

```

## Prepare medians for plotting
```{r}
# 1) extract and compute means
fixed_male_bodymass_z <- colnames(fixef_male_bodymass_no_int)
means_male_bodymass_z <- apply(fixef_male_bodymass_no_int, 2, mean)
means_male_bodymass_df_z <- data.frame(
  parameter = fixed_male_bodymass_z,
  mean      = means_male_bodymass_z,
  stringsAsFactors = FALSE
)

# 2) clean the labels
colnames(fixef_male_bodymass_no_int)         <- clean_labels(colnames(fixef_male_bodymass_no_int))
means_male_bodymass_df_z$parameter           <- clean_labels(means_male_bodymass_df_z$parameter)

# 3) plot
p_fixed_male_bodymass_z <- mcmc_areas_ridges(
  fixef_male_bodymass_no_int,
  regex_pars = ".*",  # now match everything
  prob       = 0.95
) +
  labs(
    title = "Male Body Mass",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8) +
  geom_point(
    data     = means_male_bodymass_df_z,
    aes(x = mean, y = parameter),
    shape    = 124, size = 3, color = "blue",
    position = position_nudge(y = 0.5)
  )

# display
p_fixed_male_bodymass_z

```

### Random effects density plot
```{r}
random_intercept_male_bodymass_z <- grep(
  "Intercept", 
  colnames(raneff_male_bodymass_z), 
  value = TRUE
)
random_slope_male_bodymass_z <- grep("TimeLate", colnames(raneff_male_bodymass_z), value = TRUE)
random_slope_male_bodymass_z <- random_slope_male_bodymass_z[!grepl("Austronesian", random_slope_male_bodymass_z)]
# 5a) Plot random intercepts
p_random_intercepts_male_bodymass_z <- mcmc_areas(
  raneff_male_bodymass_z,
  pars = random_intercept_male_bodymass_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Male Body Mass Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5b) Plot random slopes for Time
p_random_slopes_male_bodymass_z <- mcmc_areas(
  raneff_male_bodymass_z,
  pars = random_slope_male_bodymass_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Male Body Mass Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 6) Display them separately, or side‐by‐side:
print(p_random_intercepts_male_bodymass_z)
print(p_random_slopes_male_bodymass_z)

# Or, side‐by‐side with patchwork:
# library(patchwork)
# (p_random_intercepts_male_bodymass_z | p_random_slopes_male_bodymass_z) +
#   plot_layout(ncol = 2, widths = c(1, 1)) &
#   theme(plot.margin = margin(5, 5, 5, 5))
```

## Full Prediction for Male Body Mass (Early Rural)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict z-scored male body mass using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Bodymass_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_male_bodymass_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_bodymass_z,
  file = here("output", "final_male_bodymass_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Grid prediction complete and saved.\n")

```

## Full Prediction for Male Body Mass (Late Urban)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict z-scored male body mass using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Bodymass_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_male_bodymass_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_bodymass_z,
  file = here("output", "final_male_bodymass_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Grid prediction complete and saved.\n")
```





### Coordinate-only Prediction for Male Body Mass (late Urban)
```{r}
# Create geographic grid (if not already created)
grid_male_bodymass_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_bodymass_coordonly, 
                          cut(seq_len(nrow(grid_male_bodymass_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved male scaling parameters
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude - male_latitude_center) / male_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored male body mass using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_male_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  # Save predictions under a consistent name
  grid_chunk$Bodymass_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks
df_male_bodymass_coordonly_z <- do.call(rbind, predictions_coordonly_list)

# Save the coordinate-only predictions to CSV
write.csv(df_male_bodymass_coordonly_z,
          file = here("output", "male_bodymass_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for male body mass complete!\n")
```

### Coordinate-only Prediction for Male Body Mass(Early Rural)
```{r}
# Create geographic grid (if not already created)
grid_male_bodymass_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_bodymass_coordonly, 
                          cut(seq_len(nrow(grid_male_bodymass_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved male scaling parameters
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude - male_latitude_center) / male_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored male body mass using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_male_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  # Save predictions under a consistent name
  grid_chunk$Bodymass_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks
df_male_bodymass_coordonly_z <- do.call(rbind, predictions_coordonly_list)

# Save the coordinate-only predictions to CSV
write.csv(df_male_bodymass_coordonly_z,
          file = here("output", "male_bodymass_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for male body mass complete!\n")
```

###--------Early Rural-----------------
### Visualization for Full Prediction of Male Body Mass (Early rural)
```{r}
# 1. Read the predicted male body mass (z-scores)
extended_grid_male_bodymass <- read.csv(here("output", "final_female_bodymass_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_male_bodymass)

# 2. Convert z-scores back to raw body mass values using the original mean and SD
bodymass_mean <- mean(modern_male_bodymass$Bodymass, na.rm = TRUE)
bodymass_sd   <- sd(modern_male_bodymass$Bodymass, na.rm = TRUE)

extended_grid_male_bodymass <- extended_grid_male_bodymass %>%
  mutate(Bodymass_raw = Bodymass_pred_z * bodymass_sd + bodymass_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_male_bodymass <- extended_grid_male_bodymass %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Bodymass_z   = mean(Bodymass_pred_z, na.rm = TRUE),
    Bodymass_raw = mean(Bodymass_raw, na.rm = TRUE)  # optional raw value
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with basemap
rast_z_male_bodymass <- rasterFromXYZ(spatial_trends_male_bodymass[, c("Longitude", "Latitude", "Bodymass_z")])
rast_z_male_bodymass <- mask(rast_z_male_bodymass, basemap_sp_wgs84)
crs(rast_z_male_bodymass) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_male_bodymass <- as.data.frame(rasterToPoints(rast_z_male_bodymass), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_bodymass) <- c("Longitude", "Latitude", "Bodymass_z")

# 6. Plot the spatial trends of predicted male body mass (z-scored)
p_spatial_trends_z_male_bodymass_early_rural <- ggplot(spatial_trends_z_male_bodymass, aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,       # custom color palette (e.g., from viridis)
    limits = z_limits,    # set appropriate limits, e.g., c(-2, 2)
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Body Mass (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Display the plot
print(p_spatial_trends_z_male_bodymass_early_rural)
```

### Visualization for Male Body Mass Coordinate-only Prediction (Early rural)
```{r, warning=FALSE}
# Read the coordinate-only prediction CSV (z-scores)
df_male_bodymass_coordonly_z <- read.csv(here("output", "male_bodymass_pred_coordonly_chunks_z_early_rural.csv"))
head(df_male_bodymass_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_male_bodymass_coordonly_z)[colnames(df_male_bodymass_coordonly_z) == "Bodymass_pred_z"] <- "Bodymass_z"

# Convert to raster using Longitude, Latitude, and Bodymass_z
rast_male_bodymass_coordonly_z <- rasterFromXYZ(
  df_male_bodymass_coordonly_z[, c("Longitude", "Latitude", "Bodymass_z")]
)

# Mask the raster with the basemap shapefile
rast_male_bodymass_coordonly_z <- mask(rast_male_bodymass_coordonly_z, basemap_sp_wgs84)
crs(rast_male_bodymass_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_male_bodymass_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_bodymass_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_male_bodymass_coordonly_z_plot) <- c("Longitude", "Latitude", "Bodymass_z")

# Plot the residual spatial pattern in predicted male body mass (z-scored)
plot_male_bodymass_coordonly_z_early_rural <- ggplot(df_male_bodymass_coordonly_z_plot, 
                                         aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,       # your custom color palette (e.g., from viridis)
    limits = z_limits,   # set the appropriate limits for body mass z-scores
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Body Mass (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(plot_male_bodymass_coordonly_z_early_rural)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r, warning=FALSE}
# Merge full prediction and coordinate-only prediction
comparison_male_bodymass_z <- extended_grid_male_bodymass %>%
 dplyr::select(Longitude, Latitude, Bodymass_z_full = Bodymass_pred_z) %>%
  inner_join(
    df_male_bodymass_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Bodymass_z_coordonly = Bodymass_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Bodymass_z_full - Bodymass_z_coordonly
  )

comparison_male_bodymass_z <- comparison_male_bodymass_z  %>%
  filter(!is.na(Bodymass_z_full) & !is.na(Bodymass_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_male_bodymass   <- rasterFromXYZ(comparison_male_bodymass_z[, c("Longitude","Latitude","Bodymass_z_full")])
r_coord_male_bodymass  <- rasterFromXYZ(comparison_male_bodymass_z[, c("Longitude","Latitude","Bodymass_z_coordonly")])
r_env_male_bodymass    <- rasterFromXYZ(comparison_male_bodymass_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_bodymass <- stack(r_full_male_bodymass, r_coord_male_bodymass, r_env_male_bodymass)
names(r_stack_male_bodymass) <- c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect")
r_stack_masked_male_bodymass <- mask(r_stack_male_bodymass, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_bodymass <- as.data.frame(rasterToPoints(r_stack_masked_male_bodymass)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_bodymass_z_masked <- df_masked_male_bodymass %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_bodymass_long_z_masked <- comparison_male_bodymass_z_masked %>%
  pivot_longer(c(Bodymass_z_full, Bodymass_z_coordonly, Env_effect),
               names_to="Model", values_to="Bodymass_z") %>%
  mutate(Model = factor(Model,
    levels = c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_models_z_male_bodymass_early_rural <- ggplot(comparison_male_bodymass_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_male_bodymass,  
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(), 
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_male_bodymass_early_rural
```
###--------Late Urban-----------------
### Visualization for Full Prediction of Male Body Mass (Late Urban)
```{r}
# 1. Read the predicted male body mass (z-scores)
extended_grid_male_bodymass <- read.csv(here("output", "final_female_bodymass_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_male_bodymass)

# 2. Convert z-scores back to raw body mass values using the original mean and SD
bodymass_mean <- mean(modern_male_bodymass$Bodymass, na.rm = TRUE)
bodymass_sd   <- sd(modern_male_bodymass$Bodymass, na.rm = TRUE)

extended_grid_male_bodymass <- extended_grid_male_bodymass %>%
  mutate(Bodymass_raw = Bodymass_pred_z * bodymass_sd + bodymass_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_male_bodymass <- extended_grid_male_bodymass %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Bodymass_z   = mean(Bodymass_pred_z, na.rm = TRUE),
    Bodymass_raw = mean(Bodymass_raw, na.rm = TRUE)  # optional raw value
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with basemap
rast_z_male_bodymass <- rasterFromXYZ(spatial_trends_male_bodymass[, c("Longitude", "Latitude", "Bodymass_z")])
rast_z_male_bodymass <- mask(rast_z_male_bodymass, basemap_sp_wgs84)
crs(rast_z_male_bodymass) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_male_bodymass <- as.data.frame(rasterToPoints(rast_z_male_bodymass), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_bodymass) <- c("Longitude", "Latitude", "Bodymass_z")

# 6. Plot the spatial trends of predicted male body mass (z-scored)
p_spatial_trends_z_male_bodymass_late_urban <- ggplot(spatial_trends_z_male_bodymass, aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,       # custom color palette (e.g., from viridis)
    limits = z_limits,    # set appropriate limits, e.g., c(-2, 2)
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Body Mass (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Display the plot
print(p_spatial_trends_z_male_bodymass_late_urban)
```

### Visualization for Male Body Mass Coordinate-only Prediction (Late urban)
```{r, warning=FALSE}
# Read the coordinate-only prediction CSV (z-scores)
df_male_bodymass_coordonly_z <- read.csv(here("output", "male_bodymass_pred_coordonly_chunks_z_late_urban.csv"))
head(df_male_bodymass_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_male_bodymass_coordonly_z)[colnames(df_male_bodymass_coordonly_z) == "Bodymass_pred_z"] <- "Bodymass_z"

# Convert to raster using Longitude, Latitude, and Bodymass_z
rast_male_bodymass_coordonly_z <- rasterFromXYZ(
  df_male_bodymass_coordonly_z[, c("Longitude", "Latitude", "Bodymass_z")]
)

# Mask the raster with the basemap shapefile
rast_male_bodymass_coordonly_z <- mask(rast_male_bodymass_coordonly_z, basemap_sp_wgs84)
crs(rast_male_bodymass_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_male_bodymass_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_bodymass_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_male_bodymass_coordonly_z_plot) <- c("Longitude", "Latitude", "Bodymass_z")

# Plot the residual spatial pattern in predicted male body mass (z-scored)
plot_male_bodymass_coordonly_z_late_urban <- ggplot(df_male_bodymass_coordonly_z_plot, 
                                         aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,       # your custom color palette (e.g., from viridis)
    limits = z_limits,   # set the appropriate limits for body mass z-scores
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Body Mass (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(plot_male_bodymass_coordonly_z_late_urban)
``` 

### Comparing "Full model" vs "Coordinate-only" prediction (Late urban)
```{r, warning=FALSE}
# Merge full prediction and coordinate-only prediction
comparison_male_bodymass_z <- extended_grid_male_bodymass %>%
 dplyr::select(Longitude, Latitude, Bodymass_z_full = Bodymass_pred_z) %>%
  inner_join(
    df_male_bodymass_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Bodymass_z_coordonly = Bodymass_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Bodymass_z_full - Bodymass_z_coordonly
  )

comparison_male_bodymass_z <- comparison_male_bodymass_z  %>%
  filter(!is.na(Bodymass_z_full) & !is.na(Bodymass_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_male_bodymass   <- rasterFromXYZ(comparison_male_bodymass_z[, c("Longitude","Latitude","Bodymass_z_full")])
r_coord_male_bodymass  <- rasterFromXYZ(comparison_male_bodymass_z[, c("Longitude","Latitude","Bodymass_z_coordonly")])
r_env_male_bodymass    <- rasterFromXYZ(comparison_male_bodymass_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_bodymass <- stack(r_full_male_bodymass, r_coord_male_bodymass, r_env_male_bodymass)
names(r_stack_male_bodymass) <- c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect")
r_stack_masked_male_bodymass <- mask(r_stack_male_bodymass, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_bodymass <- as.data.frame(rasterToPoints(r_stack_masked_male_bodymass)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_bodymass_z_masked <- df_masked_male_bodymass %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_bodymass_long_z_masked <- comparison_male_bodymass_z_masked %>%
  pivot_longer(c(Bodymass_z_full, Bodymass_z_coordonly, Env_effect),
               names_to="Model", values_to="Bodymass_z") %>%
  mutate(Model = factor(Model,
    levels = c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_models_z_male_bodymass_late_urban <- ggplot(comparison_male_bodymass_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_male_bodymass,  
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(), 
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_male_bodymass_late_urban
```

#### Highlighting environmental effets
```{r, warning=FALSE}
p_env_effect_masked_male_bodymass <- ggplot(comparison_male_bodymass_z_masked, 
                              aes(x = Longitude, y = Latitude)) +
  geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
  geom_raster(data = subset(comparison_male_bodymass_z_masked, Env_effect_category == "Weak"), 
              fill = "grey90") +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "Environmental\nEffect (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
       # Add original sites as points
  geom_point(data = modern_male_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "D) Environmental Effect (Masked by Strength)",
    subtitle = "Gray = Weak Effect (|z| < 0.3)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    plot.title = element_text(size = 6, face = "bold"),
    plot.subtitle = element_text(size = 6),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_env_effect_masked_male_bodymass
```

```{r, warning=FALSE}
for (threshold in c(0.1, 0.3, 0.5)) {
  cat("Threshold:", threshold, "\n")
  
  tmp_df <- comparison_male_bodymass_z_masked %>%
    mutate(Env_effect_category = if_else(abs(Env_effect) >= threshold, "Strong", "Weak"))
  
  p_tmp <- ggplot(tmp_df, aes(x = Longitude, y = Latitude)) +
    geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
    geom_raster(data = subset(tmp_df, Env_effect_category == "Weak"),
                fill = "grey90") +
    scale_fill_gradientn(
      colors = male_colors_z, limits = z_limits, na.value = "transparent",
      name = "Environmental\nEffect (z-score)"
    ) +
     # Add original sites as points
  geom_point(data = modern_male_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.5, 
             shape = 24, 
             fill = "grey", 
             color = "red", 
             stroke = 0.5,
             inherit.aes = FALSE) +
    coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    ggtitle(paste0("Environmental Effect (Threshold ", threshold, ")")) +
    theme_minimal()
  
  print(p_tmp)
}
```

### Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_male_bodymass <- conditional_effects(fit_modern_male_bodymass_scaled, effects = "altitude_scaled")
p_altitude_male_bodymass <- plot(ce_altitude_male_bodymass, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_male_bodymass <- min(modern_male_bodymass$altitude_scaled, na.rm = TRUE)
altitude_max_male_bodymass <- max(modern_male_bodymass$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_male_bodymass <- p_altitude_male_bodymass +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.56, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.56, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_male_bodymass$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  # —— bottom-only “ticks” using geom_jitter() ——  
  geom_jitter(
    data     = modern_male_bodymass,
    mapping  = aes(x = altitude_scaled, y = -Inf), # anchor at bottom
    inherit.aes = FALSE,
    shape    = 124,                               # vertical bar “|”
    size     = 3,                                 # thickness of the tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") + 
  # Range markers
  geom_vline(xintercept = altitude_min_male_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_male_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_male_bodymass, y = Inf, 
           label = paste("Min =", round(altitude_min_male_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_male_bodymass, y = Inf, 
           label = paste("Max =", round(altitude_max_male_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Body Mass (Z-score)"
  )

print(p_altitude_jitter_ticks_male_bodymass)

modern_male_bodymass %>%
  filter(altitude_scaled > 1.56)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_male_bodymass <- conditional_effects(fit_modern_male_bodymass_scaled, effects = "mintemp_scaled")
p_mintemp_male_bodymass <- plot(ce_mintemp_male_bodymass, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_male_bodymass <- min(modern_male_bodymass$mintemp_scaled, na.rm = TRUE)
temp_max_male_bodymass<- max(modern_male_bodymass$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_male_bodymass <- p_mintemp_male_bodymass +
  geom_jitter(
    data     = modern_male_bodymass,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = temp_min_male_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_male_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_male_bodymass, y = Inf, label = paste("Min =", round(temp_min_male_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_male_bodymass, y = Inf, label = paste("Max =", round(temp_max_male_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Body Mass (Z-score)"
  ) 

print(p_mintemp_updated_male_bodymass)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_male_bodymass <- conditional_effects(fit_modern_male_bodymass_scaled, effects = "maxtemp_scaled")
p_maxtemp_male_bodymass <- plot(ce_maxtemp_male_bodymass, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_male_bodymass <- min(modern_male_bodymass$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_male_bodymass <- max(modern_male_bodymass$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_male_bodymass <- p_maxtemp_male_bodymass +
  geom_jitter(
    data = modern_male_bodymass,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxtemp_min_male_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_male_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_male_bodymass, y = Inf, label = paste("Min =", round(maxtemp_min_male_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_male_bodymass, y = Inf, label = paste("Max =", round(maxtemp_max_male_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Body Mass (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxtemp_updated_male_bodymass)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_male_bodymass <- conditional_effects(fit_modern_male_bodymass_scaled, effects = "minprecip_scaled")
p_minprecip_male_bodymass <- plot(ce_minprecip_male_bodymass, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_male_bodymass <- min(modern_male_bodymass$minprecip_scaled, na.rm = TRUE)
minprecip_max_male_bodymass <- max(modern_male_bodymass$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_male_bodymass <- p_minprecip_male_bodymass +
  geom_jitter(
    data = modern_male_bodymass,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = minprecip_min_male_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_male_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_male_bodymass, y = Inf, label = paste("Min =", round(minprecip_min_male_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_male_bodymass, y = Inf, label = paste("Max =", round(minprecip_max_male_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Body Mass (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible
print(p_minprecip_updated_male_bodymass)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r, warning=FALSE}
ce_maxprecip_male_bodymass <- conditional_effects(fit_modern_male_bodymass_scaled, effects = "maxprecip_scaled")
p_maxprecip_male_bodymass <- plot(ce_maxprecip_male_bodymass, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_male_bodymass <- min(modern_male_bodymass$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_male_bodymass <- max(modern_male_bodymass$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_male_bodymass <- p_maxprecip_male_bodymass +
  geom_jitter(
    data = modern_male_bodymass,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxprecip_min_male_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_male_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_male_bodymass, y = Inf, label = paste("Min =", round(maxprecip_min_male_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_male_bodymass, y = Inf, label = paste("Max =", round(maxprecip_max_male_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Body Mass (Z-score)"
  )+
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxprecip_updated_male_bodymass)
```

#### Check the extereme cases
```{r}
modern_male_bodymass %>%
  filter(mintemp_scaled > 1.5)
modern_male_bodymass %>%
  filter(mintemp_scaled < - 2)
modern_male_bodymass %>%
  filter(maxtemp_scaled > 1)
modern_male_bodymass %>%
  filter(maxtemp_scaled < - 3)
modern_male_bodymass %>%
  filter(minprecip_scaled > 3)
modern_male_bodymass %>%
  filter(minprecip_scaled < 0)
modern_male_bodymass %>%
  filter(maxprecip_scaled > 3)
modern_male_bodymass %>%
  filter(maxprecip_scaled < -1)
```



# Male Relative Sitting Height
```{r}
modern_male_r_sittinght <- male_data %>%
filter(!is.na(RSittinght)) %>%  # keep only the non‐missing RSittinght
  mutate(
    RSittinght = as.numeric(RSittinght),
    longitude_scaled = as.numeric(scale(Longitude)[,1]),
    latitude_scaled  = as.numeric(scale(Latitude)[,1]),
    mintemp_scaled   = as.numeric(scale(Mintemp)[,1]),
    maxtemp_scaled   = as.numeric(scale(Maxtemp)[,1]),
    minprecip_scaled = as.numeric(scale(Minprecip)[,1]),
    maxprecip_scaled = as.numeric(scale(Maxprecip)[,1]),
    altitude_scaled  = as.numeric(scale(Altitude)[,1]),
    RSittinght_z     = as.numeric(scale(RSittinght)[,1])
  )

# Compute Means & SDs for RSittinght (for z-scoring predictions)
 mean(modern_male_r_sittinght$RSittinght, na.rm = TRUE)
 sd(modern_male_r_sittinght$RSittinght, na.rm = TRUE)
```

```{r}
male_r_sittinght_formula_scaled <- bf(
  RSittinght_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_male_r_sittinght_scaled <- brm(
  formula = male_r_sittinght_formula_scaled,
  data = modern_male_r_sittinght,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

summary(fit_modern_male_r_sittinght_scaled)
```

## Extract posterior draws
```{r, warning=FALSE}
# Extract posterior draws
post_draws_male_r_sittinght_z <- as_draws_df(fit_modern_male_r_sittinght_scaled)

# Extract fixed effects (parameters starting with "b_")
fixef_male_r_sittinght_z <- post_draws_male_r_sittinght_z[, grepl("^b_", colnames(post_draws_male_r_sittinght_z))]

# Remove intercept
fixef_male_r_sittinght_no_int <- fixef_male_r_sittinght_z[, !grepl("Intercept", colnames(fixef_male_r_sittinght_z))]

# Extract random effects
raneff_male_r_sittinght_z <- post_draws_male_r_sittinght_z[, grepl("^r_Langsubgroup", colnames(post_draws_male_r_sittinght_z))]
```

## Plot posterior distributions
```{r}
# 2) compute means
fixed_male_r_sittinght_z <- colnames(fixef_male_r_sittinght_no_int)
means_male_r_sittinght_z <- apply(fixef_male_r_sittinght_no_int, 2, mean)
means_male_r_sittinght_df_z <- data.frame(
  parameter = fixed_male_r_sittinght_z,
  mean      = means_male_r_sittinght_z,
  stringsAsFactors = FALSE
)

# 3) clean both the draw‐matrix and the means df
colnames(fixef_male_r_sittinght_no_int) <- clean_labels(colnames(fixef_male_r_sittinght_no_int))
means_male_r_sittinght_df_z$parameter   <- clean_labels(means_male_r_sittinght_df_z$parameter)

# 4) plot
p_fixed_male_r_sittinght_z <- mcmc_areas_ridges(
  fixef_male_r_sittinght_no_int,
  regex_pars = ".*",  # now match everything
  prob       = 0.95
) +
  labs(
    title = "Male Relative Sitting Height",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8) +
  geom_point(
    data     = means_male_r_sittinght_df_z,
    aes(x = mean, y = parameter),
    shape    = 124, size = 5, color = "blue",
    position = position_nudge(y = 0.5)
  )

# Print the plot
p_fixed_male_r_sittinght_z


```

### Random effects density plot
```{r}
# 2) Identify random‐intercept vs. random‐slope columns
random_intercept_male_r_sittinght_z <- grep(
  "Intercept", 
  colnames(raneff_male_r_sittinght_z), 
  value = TRUE
)

random_slope_male_r_sittinght_z <- grep("TimeLate", colnames(raneff_male_r_sittinght_z), value = TRUE)
random_slope_male_r_sittinght_z <- random_slope_male_r_sittinght_z[!grepl("Austronesian", random_slope_male_r_sittinght_z)]

# 4a) Plot random intercepts for relative sitting height
p_random_intercepts_male_r_sittinght_z <- mcmc_areas(
  raneff_male_r_sittinght_z,
  pars = random_intercept_male_r_sittinght_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Male Relative Sitting Height Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 4b) Plot random slopes for TimeLate
p_random_slopes_male_r_sittinght_z <- mcmc_areas(
  raneff_male_r_sittinght_z,
  pars = random_slope_male_r_sittinght_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Male Relative Sitting Height Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5) Display them separately
print(p_random_intercepts_male_r_sittinght_z)
print(p_random_slopes_male_r_sittinght_z)

#—or side‑by‑side—
# library(patchwork)
# (p_random_intercepts_male_r_sittinght_z | p_random_slopes_male_r_sittinght_z) +
#   plot_layout(ncol = 2) &
#   theme(plot.margin = margin(5,5,5,5))
```

## Full Prediction for Male Relative Sitting Height (Early Rural)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict z-scored male relative sitting height using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RSittinght_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_male_r_sittinght_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_r_sittinght_z,
  file = here("output", "final_male_r_sittinght_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Grid prediction for male relative sitting height complete and saved.\n")
```

## Full Prediction for Male Relative Sitting Height (Late Urban)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict z-scored male relative sitting height using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RSittinght_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_male_r_sittinght_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_r_sittinght_z,
  file = here("output", "final_male_r_sittinght_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Grid prediction for male relative sitting height complete and saved.\n")
```


## Coordinate-only Prediction for Male Relative Sitting Height (Early Rural)
```{r}
# Create geographic grid (if not already created)
grid_male_r_sittinght_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_r_sittinght_coordonly, 
                          cut(seq_len(nrow(grid_male_r_sittinght_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved male parameters
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude - male_latitude_center) / male_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored male relative sitting height using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_male_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$RSittinght_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks
df_male_r_sittinght_coordonly_z <- do.call(rbind, predictions_coordonly_list)

# Save the coordinate-only predictions to CSV
write.csv(df_male_r_sittinght_coordonly_z,
          file = here("output", "male_r_sittinght_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for male relative sitting height complete!\n")
```

## Coordinate-only Prediction for Male Relative Sitting Height (Late Urban)
```{r}
# Create geographic grid (if not already created)
grid_male_r_sittinght_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_r_sittinght_coordonly, 
                          cut(seq_len(nrow(grid_male_r_sittinght_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved male parameters
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude - male_latitude_center) / male_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored male relative sitting height using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_male_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$RSittinght_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks
df_male_r_sittinght_coordonly_z <- do.call(rbind, predictions_coordonly_list)

# Save the coordinate-only predictions to CSV
write.csv(df_male_r_sittinght_coordonly_z,
          file = here("output", "male_r_sittinght_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for male relative sitting height complete!\n")
```
###--------Early Rural-----------------
### Visualization for Full Prediction of Male Relative Sitting Height (Eraly Rural)
```{r, warning=FALSE}
# 1. Read the predicted male relative sitting height (z-scores)
extended_grid_male_r_sittinght <- read.csv(here("output", "final_male_r_sittinght_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_male_r_sittinght)

# 2. Convert z-scores back to raw relative sitting height using the original mean and SD
r_sittinght_mean <- mean(modern_male_r_sittinght$RSittinght, na.rm = TRUE)
r_sittinght_sd   <- sd(modern_male_r_sittinght$RSittinght, na.rm = TRUE)

extended_grid_male_r_sittinght <- extended_grid_male_r_sittinght %>%
  mutate(RSittinght_raw = RSittinght_pred_z * r_sittinght_sd + r_sittinght_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_male_r_sittinght <- extended_grid_male_r_sittinght %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RSittinght_z   = mean(RSittinght_pred_z, na.rm = TRUE),
    RSittinght_raw = mean(RSittinght_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with basemap
rast_z_male_r_sittinght <- rasterFromXYZ(spatial_trends_male_r_sittinght[, c("Longitude", "Latitude", "RSittinght_z")])
rast_z_male_r_sittinght <- mask(rast_z_male_r_sittinght, basemap_sp_wgs84)
crs(rast_z_male_r_sittinght) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_male_r_sittinght <- as.data.frame(rasterToPoints(rast_z_male_r_sittinght), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_r_sittinght) <- c("Longitude", "Latitude", "RSittinght_z")

# 6. Plot the spatial trends of predicted male relative sitting height (z-scored)
p_spatial_trends_z_male_r_sittinght_early_rural <- ggplot(spatial_trends_z_male_r_sittinght, aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,        # your custom color palette
    limits = z_limits,   # set appropriate limits (e.g., c(-2, 2)) for RSittinght z-scores
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Relative Sitting Height (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_male_r_sittinght_early_rural)
```

### Visualization for Coordinate-only Prediction of Male Relative Sitting Height (early rural)
```{r, warning=FALSE}
# Read the coordinate-only prediction CSV (z-scores)
df_male_r_sittinght_coordonly_z <- read.csv(here("output", "male_r_sittinght_pred_coordonly_chunks_z_early_rural.csv"))
head(df_male_r_sittinght_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_male_r_sittinght_coordonly_z)[colnames(df_male_r_sittinght_coordonly_z) == "RSittinght_pred_z"] <- "RSittinght_z"

# Convert to raster using Longitude, Latitude, and RSittinght_z
rast_male_r_sittinght_coordonly_z <- rasterFromXYZ(
  df_male_r_sittinght_coordonly_z[, c("Longitude", "Latitude", "RSittinght_z")]
)

# Mask the raster with the basemap shapefile
rast_male_r_sittinght_coordonly_z <- mask(rast_male_r_sittinght_coordonly_z, basemap_sp_wgs84)
crs(rast_male_r_sittinght_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_male_r_sittinght_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_r_sittinght_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_male_r_sittinght_coordonly_z_plot) <- c("Longitude", "Latitude", "RSittinght_z")

# Plot the residual spatial pattern in predicted male relative sitting height (z-scored)
plot_male_r_sittinght_coordonly_z_early_rural <- ggplot(df_male_r_sittinght_coordonly_z_plot, 
                                            aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,       # your custom color palette (e.g., from viridis)
    limits = z_limits,   # set appropriate limits for RSittinght z-scores
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Relative Sitting Height (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(plot_male_r_sittinght_coordonly_z_early_rural)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_male_rsh_z <- extended_grid_male_r_sittinght %>%
 dplyr::select(Longitude, Latitude, RSittinght_z_full = RSittinght_pred_z) %>%
  inner_join(
    df_male_r_sittinght_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RSittinght_z_coordonly = RSittinght_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RSittinght_z_full - RSittinght_z_coordonly
  )

comparison_male_rsh_z <- comparison_male_rsh_z  %>%
  filter(!is.na(RSittinght_z_full) & !is.na(RSittinght_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_male_rsh   <- rasterFromXYZ(comparison_male_rsh_z[, c("Longitude","Latitude","RSittinght_z_full")])
r_coord_male_rsh <- rasterFromXYZ(comparison_male_rsh_z[, c("Longitude","Latitude","RSittinght_z_coordonly")])
r_env_male_rsh    <- rasterFromXYZ(comparison_male_rsh_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_rsh <- stack(r_full_male_rsh, r_coord_male_rsh, r_env_male_rsh)
names(r_stack_male_rsh) <- c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect")
r_stack_masked_male_rsh <- mask(r_stack_male_rsh, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_rsh <- as.data.frame(rasterToPoints(r_stack_masked_male_rsh)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_rsh_z_masked <- df_masked_male_rsh %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_rsh_long_z_masked <- comparison_male_rsh_z_masked %>%
  pivot_longer(c(RSittinght_z_full, RSittinght_z_coordonly, Env_effect),
               names_to="Model", values_to="RSittinght_z") %>%
  mutate(Model = factor(Model,
    levels = c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_male_rsh_early_rural <- ggplot(comparison_male_rsh_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text =element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_male_rsh_early_rural
```

###--------Late Urban-----------------
### Visualization for Full Prediction of Male Relative Sitting Height (Late Urban)
```{r, warning=FALSE}
# 1. Read the predicted male relative sitting height (z-scores)
extended_grid_male_r_sittinght <- read.csv(here("output", "final_male_r_sittinght_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_male_r_sittinght)

# 2. Convert z-scores back to raw relative sitting height using the original mean and SD
r_sittinght_mean <- mean(modern_male_r_sittinght$RSittinght, na.rm = TRUE)
r_sittinght_sd   <- sd(modern_male_r_sittinght$RSittinght, na.rm = TRUE)

extended_grid_male_r_sittinght <- extended_grid_male_r_sittinght %>%
  mutate(RSittinght_raw = RSittinght_pred_z * r_sittinght_sd + r_sittinght_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_male_r_sittinght <- extended_grid_male_r_sittinght %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RSittinght_z   = mean(RSittinght_pred_z, na.rm = TRUE),
    RSittinght_raw = mean(RSittinght_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with basemap
rast_z_male_r_sittinght <- rasterFromXYZ(spatial_trends_male_r_sittinght[, c("Longitude", "Latitude", "RSittinght_z")])
rast_z_male_r_sittinght <- mask(rast_z_male_r_sittinght, basemap_sp_wgs84)
crs(rast_z_male_r_sittinght) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_male_r_sittinght <- as.data.frame(rasterToPoints(rast_z_male_r_sittinght), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_r_sittinght) <- c("Longitude", "Latitude", "RSittinght_z")

# 6. Plot the spatial trends of predicted male relative sitting height (z-scored)
p_spatial_trends_z_male_r_sittinght_late_urban <- ggplot(spatial_trends_z_male_r_sittinght, aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,        # your custom color palette
    limits = z_limits,   # set appropriate limits (e.g., c(-2, 2)) for RSittinght z-scores
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Relative Sitting Height (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_male_r_sittinght_late_urban)
```

### Visualization for Coordinate-only Prediction of Male Relative Sitting Height (late urban)
```{r, warning=FALSE}
# Read the coordinate-only prediction CSV (z-scores)
df_male_r_sittinght_coordonly_z <- read.csv(here("output", "male_r_sittinght_pred_coordonly_chunks_z_late_urban.csv"))
head(df_male_r_sittinght_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_male_r_sittinght_coordonly_z)[colnames(df_male_r_sittinght_coordonly_z) == "RSittinght_pred_z"] <- "RSittinght_z"

# Convert to raster using Longitude, Latitude, and RSittinght_z
rast_male_r_sittinght_coordonly_z <- rasterFromXYZ(
  df_male_r_sittinght_coordonly_z[, c("Longitude", "Latitude", "RSittinght_z")]
)

# Mask the raster with the basemap shapefile
rast_male_r_sittinght_coordonly_z <- mask(rast_male_r_sittinght_coordonly_z, basemap_sp_wgs84)
crs(rast_male_r_sittinght_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_male_r_sittinght_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_r_sittinght_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_male_r_sittinght_coordonly_z_plot) <- c("Longitude", "Latitude", "RSittinght_z")

# Plot the residual spatial pattern in predicted male relative sitting height (z-scored)
plot_male_r_sittinght_coordonly_z_late_urban <- ggplot(df_male_r_sittinght_coordonly_z_plot, 
                                            aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,       # your custom color palette (e.g., from viridis)
    limits = z_limits,   # set appropriate limits for RSittinght z-scores
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Relative Sitting Height (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(plot_male_r_sittinght_coordonly_z_late_urban)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_male_rsh_z <- extended_grid_male_r_sittinght %>%
 dplyr::select(Longitude, Latitude, RSittinght_z_full = RSittinght_pred_z) %>%
  inner_join(
    df_male_r_sittinght_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RSittinght_z_coordonly = RSittinght_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RSittinght_z_full - RSittinght_z_coordonly
  )

comparison_male_rsh_z <- comparison_male_rsh_z  %>%
  filter(!is.na(RSittinght_z_full) & !is.na(RSittinght_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_male_rsh   <- rasterFromXYZ(comparison_male_rsh_z[, c("Longitude","Latitude","RSittinght_z_full")])
r_coord_male_rsh <- rasterFromXYZ(comparison_male_rsh_z[, c("Longitude","Latitude","RSittinght_z_coordonly")])
r_env_male_rsh    <- rasterFromXYZ(comparison_male_rsh_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_rsh <- stack(r_full_male_rsh, r_coord_male_rsh, r_env_male_rsh)
names(r_stack_male_rsh) <- c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect")
r_stack_masked_male_rsh <- mask(r_stack_male_rsh, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_rsh <- as.data.frame(rasterToPoints(r_stack_masked_male_rsh)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_rsh_z_masked <- df_masked_male_rsh %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_rsh_long_z_masked <- comparison_male_rsh_z_masked %>%
  pivot_longer(c(RSittinght_z_full, RSittinght_z_coordonly, Env_effect),
               names_to="Model", values_to="RSittinght_z") %>%
  mutate(Model = factor(Model,
    levels = c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_male_rsh_late_urban <- ggplot(comparison_male_rsh_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text =element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_male_rsh_late_urban
```



#### Highlighting environmental effets
```{r, warning=FALSE}
p_env_effect_masked_male_rsh <- ggplot(comparison_male_rsh_z_masked, 
                              aes(x = Longitude, y = Latitude)) +
  geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
  geom_raster(data = subset(comparison_male_rsh_z_masked, Env_effect_category == "Weak"), 
              fill = "grey90") +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "Environmental\nEffect (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
       # Add original sites as points
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "D) Environmental Effect (Masked by Strength)",
    subtitle = "Gray = Weak Effect (|z| < 0.3)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    plot.title = element_text(size = 6, face = "bold"),
    plot.subtitle = element_text(size = 6),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_env_effect_masked_male_rsh
```

```{r, warning=FALSE}
for (threshold in c(0.1, 0.3, 0.5)) {
  cat("Threshold:", threshold, "\n")
  
  tmp_df <- comparison_male_rsh_z_masked %>%
    mutate(Env_effect_category = if_else(abs(Env_effect) >= threshold, "Strong", "Weak"))
  
  p_tmp <- ggplot(tmp_df, aes(x = Longitude, y = Latitude)) +
    geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
    geom_raster(data = subset(tmp_df, Env_effect_category == "Weak"),
                fill = "grey90") +
    scale_fill_gradientn(
      colors = male_colors_z, limits = z_limits, na.value = "transparent",
      name = "Environmental\nEffect (z-score)"
    ) +
     # Add original sites as points
  geom_point(data = modern_male_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.5, 
             shape = 24, 
             fill = "grey", 
             color = "red", 
             stroke = 0.5,
             inherit.aes = FALSE) +
    coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    ggtitle(paste0("Environmental Effect (Threshold ", threshold, ")")) +
    theme_minimal()
  
  print(p_tmp)
}
```

### Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_male_rsh <- conditional_effects(fit_modern_male_r_sittinght_scaled, effects = "altitude_scaled")
p_altitude_male_rsh <- plot(ce_altitude_male_rsh, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_male_rsh <- min(modern_male_r_sittinght$altitude_scaled, na.rm = TRUE)
altitude_max_male_rsh <- max(modern_male_r_sittinght$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_male_rsh <- p_altitude_male_rsh +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.6, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.6, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_male_rsh$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  geom_jitter(
    data       = modern_male_r_sittinght,
   mapping  = aes(x = altitude_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  # Range markers
  geom_vline(xintercept = altitude_min_male_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_male_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_male_rsh, y = Inf, 
           label = paste("Min =", round(altitude_min_male_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_male_rsh, y = Inf, 
           label = paste("Max =", round(altitude_max_male_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Relative Sitting Height (Z-score)"
  )

print(p_altitude_jitter_ticks_male_rsh)

modern_male_r_sittinght %>%
  filter(altitude_scaled > 1.6)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_male_rsh <- conditional_effects(fit_modern_male_r_sittinght_scaled, effects = "mintemp_scaled")
p_mintemp_male_rsh <- plot(ce_mintemp_male_rsh, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_male_rsh  <- min(modern_male_r_sittinght$mintemp_scaled, na.rm = TRUE)
temp_max_male_rsh <- max(modern_male_r_sittinght$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_male_rsh <- p_mintemp_male_rsh +
  geom_jitter(
    data     = modern_male_r_sittinght,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1) ,
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = temp_min_male_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_male_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_male_rsh, y = Inf, label = paste("Min =", round(temp_min_male_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_male_rsh, y = Inf, label = paste("Max =", round(temp_max_male_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Relative Sitting Height (Z-score)"
  ) 

print(p_mintemp_updated_male_rsh)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_male_rsh <- conditional_effects(fit_modern_male_r_sittinght_scaled, effects = "maxtemp_scaled")
p_maxtemp_male_rsh <- plot(ce_maxtemp_male_rsh, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_male_rsh <- min(modern_male_r_sittinght$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_male_rsh <- max(modern_male_r_sittinght$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_male_rsh <- p_maxtemp_male_rsh +
  geom_jitter(
    data = modern_male_r_sittinght,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxtemp_min_male_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_male_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_male_rsh, y = Inf, label = paste("Min =", round(maxtemp_min_male_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_male_rsh, y = Inf, label = paste("Max =", round(maxtemp_max_male_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Relative Sitting Height (Z-score)"
  ) 

print(p_maxtemp_updated_male_rsh)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_male_rsh <- conditional_effects(fit_modern_male_r_sittinght_scaled, effects = "minprecip_scaled")
p_minprecip_male_rsh <- plot(ce_minprecip_male_rsh, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_male_rsh <- min(modern_male_r_sittinght$minprecip_scaled, na.rm = TRUE)
minprecip_max_male_rsh <- max(modern_male_r_sittinght$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_male_rsh <- p_minprecip_male_rsh +
  geom_jitter(
    data = modern_male_r_sittinght,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = minprecip_min_male_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_male_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_male_rsh, y = Inf, label = paste("Min =", round(minprecip_min_male_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_male_rsh, y = Inf, label = paste("Max =", round(minprecip_max_male_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Relative Sitting Height (Z-score)"
  )
print(p_minprecip_updated_male_rsh)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r, warning=FALSE}
ce_maxprecip_male_rsh <- conditional_effects(fit_modern_male_r_sittinght_scaled, effects = "maxprecip_scaled")
p_maxprecip_male_rsh <- plot(ce_maxprecip_male_rsh, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_male_rsh <- min(modern_male_r_sittinght$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_male_rsh <- max(modern_male_r_sittinght$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_male_rsh <- p_maxprecip_male_rsh +
  geom_jitter(
    data = modern_male_r_sittinght,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxprecip_min_male_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_male_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_male_rsh, y = Inf, label = paste("Min =", round(maxprecip_min_male_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_male_rsh, y = Inf, label = paste("Max =", round(maxprecip_max_male_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Relative Sitting Height (Z-score)"
  )
print(p_maxprecip_updated_male_rsh)
```

#### Check the extereme cases
```{r}
modern_male_r_sittinght %>%
  filter(mintemp_scaled > 1.5)
modern_male_r_sittinght %>%
  filter(mintemp_scaled < - 2)
modern_male_r_sittinght %>%
  filter(maxtemp_scaled > 1)
modern_male_r_sittinght %>%
  filter(maxtemp_scaled < - 3)
modern_male_r_sittinght %>%
  filter(minprecip_scaled > 3)
modern_male_r_sittinght %>%
  filter(minprecip_scaled < 0)
modern_male_r_sittinght%>%
  filter(maxprecip_scaled > 3)
modern_male_r_sittinght %>%
  filter(maxprecip_scaled < -1)
```


# Male Relative Body Breadth
```{r}
modern_male_rbb <- male_data %>%
    filter(!is.na(RelativeBodyBreadth)) %>%
 mutate(
    RelativeBodyBreadth = as.numeric(RelativeBodyBreadth),
    longitude_scaled     = as.numeric(scale(Longitude)[,1]),
    latitude_scaled      = as.numeric(scale(Latitude)[,1]),
    mintemp_scaled       = as.numeric(scale(Mintemp)[,1]),
    maxtemp_scaled       = as.numeric(scale(Maxtemp)[,1]),
    minprecip_scaled     = as.numeric(scale(Minprecip)[,1]),
    maxprecip_scaled     = as.numeric(scale(Maxprecip)[,1]),
    altitude_scaled  = as.numeric(scale(Altitude)[,1]),
    RelativeBodyBreadth_z = as.numeric(scale(RelativeBodyBreadth)[,1])
  )
mean(modern_male_rbb$RelativeBodyBreadth)
sd(modern_male_rbb$RelativeBodyBreadth)
```

```{r}
male_relativebodybreadth_formula_scaled <- bf(
  RelativeBodyBreadth_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_male_relativebodybreadth_scaled <- brm(
  formula = male_relativebodybreadth_formula_scaled,
  data = modern_male_rbb,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

summary(fit_modern_male_relativebodybreadth_scaled)
```

## Extract posterior draws
```{r, warning=FALSE}
# Extract posterior draws
post_draws_male_rbb_z <- as_draws_df(fit_modern_male_relativebodybreadth_scaled)

# Extract fixed effects (parameters starting with "b_")
fixef_male_rbb_z <- post_draws_male_rbb_z[, grepl("^b_", colnames(post_draws_male_rbb_z))]

# Remove intercept
fixef_male_rbb_no_int <- fixef_male_rbb_z[, !grepl("Intercept", colnames(fixef_male_rbb_z))]

# Extract random effects
raneff_male_rbb_z <- post_draws_male_rbb_z[, grepl("^r_Langsubgroup", colnames(post_draws_male_rbb_z))]
```

## Plot posterior distributions
```{r}
# 1) extract and compute means
fixed_male_rbb_z <- colnames(fixef_male_rbb_no_int)
means_male_rbb_z <- apply(fixef_male_rbb_no_int, 2, mean)
means_male_rbb_df_z <- data.frame(
  parameter = fixed_male_rbb_z,
  mean      = means_male_rbb_z,
  stringsAsFactors = FALSE
)

# 2) clean names in both matrix and means dataframe
colnames(fixef_male_rbb_no_int)    <- clean_labels(colnames(fixef_male_rbb_no_int))
means_male_rbb_df_z$parameter      <- clean_labels(means_male_rbb_df_z$parameter)

# 3) plot
p_fixed_male_rbb_z <- mcmc_areas_ridges(
  fixef_male_rbb_no_int,
  regex_pars = ".*",  # match everything now that names are cleaned
  prob       = 0.95
) +
  labs(
    title = "Male Relative Body Breadth",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(
    xintercept = 0,
    linetype   = "dashed",
    color      = "red",
    linewidth  = 0.8
  ) +
  geom_point(
    data     = means_male_rbb_df_z,
    aes(x = mean, y = parameter),
    shape    = 124,
    size     = 3,
    color    = "blue",
    position = position_nudge(y = 0.5)
  )

# Print the plot
p_fixed_male_rbb_z

```

### Random density plot
```{r}
random_intercept_male_rbb_z <- grep("Intercept", colnames(raneff_male_rbb_z), value = TRUE)
random_slope_male_rbb_z <- grep("TimeLate", colnames(raneff_male_rbb_z), value = TRUE)
random_slope_male_rbb_z <- random_slope_male_rbb_z[!grepl("Austronesian", random_slope_male_rbb_z)]

# 5a) Plot random intercepts for relative body breadth
p_random_intercepts_male_rbb_z <- mcmc_areas(
  raneff_male_rbb_z,
  pars = random_intercept_male_rbb_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Male Relative Body Breadth Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5b) Plot random slopes for Time
p_random_slopes_male_rbb_z <- mcmc_areas(
  raneff_male_rbb_z,
  pars = random_slope_male_rbb_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Male Relative Body Breadth Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 6) Display them (separately or side‑by‑side):
print(p_random_intercepts_male_rbb_z)
print(p_random_slopes_male_rbb_z)

# Or, using patchwork:
# library(patchwork)
# (p_random_intercepts_male_rbb_z | p_random_slopes_male_rbb_z) +
#   plot_layout(ncol = 2, widths = c(1, 1)) &
#   theme(plot.margin = margin(5, 5, 5, 5))
```


## Full Prediction & Visualization for Male Relative Body Breadth
### Full Prediction (Early Rural)
```{r}
# Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# Loop over chunks and predict using the full model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict z-scored male relative body breadth using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
final_predictions_male_relativebodybreadth_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_relativebodybreadth_z,
  file = here("output", "final_male_relativebodybreadth_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Full grid prediction for male relative body breadth complete and saved.\n")

```

### Full Prediction (Late Urban)
```{r}
# Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# Loop over chunks and predict using the full model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved male parameters
      mintemp_scaled   = (Mintemp      - male_mintemp_center)   / male_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - male_maxtemp_center)   / male_maxtemp_scale,
      minprecip_scaled = (Minprecip    - male_minprecip_center) / male_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - male_maxprecip_center) / male_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - male_altitude_center)  / male_altitude_scale,
      longitude_scaled = (Longitude    - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude     - male_latitude_center)  / male_latitude_scale
    )
  
  # Predict z-scored male relative body breadth using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_male_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
final_predictions_male_relativebodybreadth_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_male_relativebodybreadth_z,
  file = here("output", "final_male_relativebodybreadth_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Full grid prediction for male relative body breadth complete and saved.\n")

```


## Coordinate‑only Prediction & Visualization for Male Relative Body Breadth
### Coordinate‑only Prediction
```{r}
# Create geographic grid (if not already created)
grid_male_relativebodybreadth_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_relativebodybreadth_coordonly, 
                          cut(seq_len(nrow(grid_male_relativebodybreadth_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved male parameters
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude - male_latitude_center) / male_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored male relative body breadth using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_male_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_male_relativebodybreadth_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_male_relativebodybreadth_coordonly_z,
          file = here("output", "male_relativebodybreadth_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for male relative body breadth complete!\n")
```

```{r}
# Create geographic grid (if not already created)
grid_male_relativebodybreadth_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_male_chunks <- split(grid_male_relativebodybreadth_coordonly, 
                          cut(seq_len(nrow(grid_male_relativebodybreadth_coordonly)), 
                              breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_male_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_male_chunks), "\n")
  
  grid_chunk <- grid_male_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved male parameters
      longitude_scaled = (Longitude - male_longitude_center) / male_longitude_scale,
      latitude_scaled  = (Latitude - male_latitude_center) / male_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored male relative body breadth using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_male_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_male_relativebodybreadth_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_male_relativebodybreadth_coordonly_z,
          file = here("output", "male_relativebodybreadth_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for male relative body breadth complete!\n")
```

###--------Early Rural-----------------
### Visualization for Full Prediction (Early Rural)
```{r, warning=FALSE}
# Read the predicted male relative body breadth (z-scores)
extended_grid_male_relativebodybreadth <- read.csv(here("output", "final_male_relativebodybreadth_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_male_relativebodybreadth)

# (Optional) Convert z-scores back to raw values using the original mean and SD from your dataset
relativebodybreadth_mean <- mean(modern_male_rbb$RelativeBodyBreadth, na.rm = TRUE)
relativebodybreadth_sd   <- sd(modern_male_rbb$RelativeBodyBreadth, na.rm = TRUE)

extended_grid_male_relativebodybreadth <- extended_grid_male_relativebodybreadth %>%
  mutate(RelativeBodyBreadth_raw = RelativeBodyBreadth_pred_z * relativebodybreadth_sd + relativebodybreadth_mean)

# Average predictions across grid cells for spatial trends
spatial_trends_male_relativebodybreadth <- extended_grid_male_relativebodybreadth %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RelativeBodyBreadth_z   = mean(RelativeBodyBreadth_pred_z, na.rm = TRUE),
    RelativeBodyBreadth_raw = mean(RelativeBodyBreadth_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# Create a raster from the z-scored predictions and mask with the basemap
rast_z_male_relativebodybreadth <- rasterFromXYZ(spatial_trends_male_relativebodybreadth[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")])
rast_z_male_relativebodybreadth <- mask(rast_z_male_relativebodybreadth, basemap_sp_wgs84)
crs(rast_z_male_relativebodybreadth) <- CRS("+proj=longlat +datum=WGS84")

# Convert the raster to a data frame for plotting
spatial_trends_z_male_relativebodybreadth <- as.data.frame(rasterToPoints(rast_z_male_relativebodybreadth), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_relativebodybreadth) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# Plot the spatial trends of predicted male relative body breadth (z-scored)
p_spatial_trends_z_male_relativebodybreadth_early_rural <- ggplot(spatial_trends_z_male_relativebodybreadth, aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,             # your custom color palette (e.g., from viridis)
    limits = z_limits,  # set appropriate limits, e.g., c(-2, 2)
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Relative Body Breadth (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_male_relativebodybreadth_early_rural)
```

### Visualization for Coordinate‑only Prediction(Early Rural)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_male_relativebodybreadth_coordonly_z <- read.csv(here("output", "male_relativebodybreadth_pred_coordonly_chunks_z_early_rural.csv"))
head(df_male_relativebodybreadth_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_male_relativebodybreadth_coordonly_z)[colnames(df_male_relativebodybreadth_coordonly_z) == "RelativeBodyBreadth_pred_z"] <- "RelativeBodyBreadth_z"

# Convert to raster using Longitude, Latitude, and RelativeBodyBreadth_z
rast_male_relativebodybreadth_coordonly_z <- rasterFromXYZ(
  df_male_relativebodybreadth_coordonly_z[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")]
)

# Mask the raster with the basemap shapefile
rast_male_relativebodybreadth_coordonly_z <- mask(rast_male_relativebodybreadth_coordonly_z, basemap_sp_wgs84)
crs(rast_male_relativebodybreadth_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_male_relativebodybreadth_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_relativebodybreadth_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_male_relativebodybreadth_coordonly_z_plot) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# Plot the residual spatial pattern in predicted male relative body breadth (z-scored)
plot_male_relativebodybreadth_coordonly_z_early_rural <- ggplot(df_male_relativebodybreadth_coordonly_z_plot, 
                                                    aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,             # your custom color palette
    limits = z_limits,  # appropriate limits for RelativeBodyBreadth z-scores
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Relative Body Breadth (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(plot_male_relativebodybreadth_coordonly_z_early_rural)
```


### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_male_RelativeBodyBreadth_z <- extended_grid_male_relativebodybreadth %>%
 dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_full = RelativeBodyBreadth_pred_z
) %>%
  inner_join(
    df_male_relativebodybreadth_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_coordonly = RelativeBodyBreadth_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RelativeBodyBreadth_z_full - RelativeBodyBreadth_z_coordonly
  )

comparison_male_RelativeBodyBreadth_z <- comparison_male_RelativeBodyBreadth_z  %>%
  filter(!is.na(RelativeBodyBreadth_z_full) & !is.na(RelativeBodyBreadth_z_coordonly) & !is.na(Env_effect))


# 1. Build individual rasters
r_full_male_rbb <- rasterFromXYZ(comparison_male_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_full")])
r_coord_male_rbb  <- rasterFromXYZ(comparison_male_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_coordonly")])
r_env_male_rbb    <- rasterFromXYZ(comparison_male_RelativeBodyBreadth_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_rbb <- stack(r_full_male_rbb, r_coord_male_rbb, r_env_male_rbb)
names(r_stack_male_rbb) <- c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect")
r_stack_masked_male_rbb <- mask(r_stack_male_rbb, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_rbb <- as.data.frame(rasterToPoints(r_stack_masked_male_rbb)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_RelativeBodyBreadth_z_masked <- df_masked_male_rbb %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_relativeBodyBreadth_long_z_masked <- comparison_male_RelativeBodyBreadth_z_masked  %>%
  pivot_longer(c(RelativeBodyBreadth_z_full, RelativeBodyBreadth_z_coordonly, Env_effect),
               names_to="Model", values_to="RelativeBodyBreadth_z") %>%
  mutate(Model = factor(Model,
    levels = c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_male_rbb_early_rural <- ggplot(comparison_male_relativeBodyBreadth_long_z_masked , 
                     aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
    # Add original sites as points
  geom_point(data = modern_male_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  )+
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_male_rbb_early_rural
```

###--------Late Urban-----------------
### Visualization for Full Prediction (Late Urban)
```{r, warning=FALSE}
# Read the predicted male relative body breadth (z-scores)
extended_grid_male_relativebodybreadth <- read.csv(here("output", "final_male_relativebodybreadth_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_male_relativebodybreadth)

# (Optional) Convert z-scores back to raw values using the original mean and SD from your dataset
relativebodybreadth_mean <- mean(modern_male_rbb$RelativeBodyBreadth, na.rm = TRUE)
relativebodybreadth_sd   <- sd(modern_male_rbb$RelativeBodyBreadth, na.rm = TRUE)

extended_grid_male_relativebodybreadth <- extended_grid_male_relativebodybreadth %>%
  mutate(RelativeBodyBreadth_raw = RelativeBodyBreadth_pred_z * relativebodybreadth_sd + relativebodybreadth_mean)

# Average predictions across grid cells for spatial trends
spatial_trends_male_relativebodybreadth <- extended_grid_male_relativebodybreadth %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RelativeBodyBreadth_z   = mean(RelativeBodyBreadth_pred_z, na.rm = TRUE),
    RelativeBodyBreadth_raw = mean(RelativeBodyBreadth_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# Create a raster from the z-scored predictions and mask with the basemap
rast_z_male_relativebodybreadth <- rasterFromXYZ(spatial_trends_male_relativebodybreadth[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")])
rast_z_male_relativebodybreadth <- mask(rast_z_male_relativebodybreadth, basemap_sp_wgs84)
crs(rast_z_male_relativebodybreadth) <- CRS("+proj=longlat +datum=WGS84")

# Convert the raster to a data frame for plotting
spatial_trends_z_male_relativebodybreadth <- as.data.frame(rasterToPoints(rast_z_male_relativebodybreadth), stringsAsFactors = FALSE)
colnames(spatial_trends_z_male_relativebodybreadth) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# Plot the spatial trends of predicted male relative body breadth (z-scored)
p_spatial_trends_z_male_relativebodybreadth_late_urban <- ggplot(spatial_trends_z_male_relativebodybreadth, aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,             # your custom color palette (e.g., from viridis)
    limits = z_limits,  # set appropriate limits, e.g., c(-2, 2)
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Male Relative Body Breadth (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_male_relativebodybreadth_late_urban)
```

### Visualization for Coordinate‑only Prediction(Late Urban)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_male_relativebodybreadth_coordonly_z <- read.csv(here("output", "male_relativebodybreadth_pred_coordonly_chunks_z_late_urban.csv"))
head(df_male_relativebodybreadth_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_male_relativebodybreadth_coordonly_z)[colnames(df_male_relativebodybreadth_coordonly_z) == "RelativeBodyBreadth_pred_z"] <- "RelativeBodyBreadth_z"

# Convert to raster using Longitude, Latitude, and RelativeBodyBreadth_z
rast_male_relativebodybreadth_coordonly_z <- rasterFromXYZ(
  df_male_relativebodybreadth_coordonly_z[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")]
)

# Mask the raster with the basemap shapefile
rast_male_relativebodybreadth_coordonly_z <- mask(rast_male_relativebodybreadth_coordonly_z, basemap_sp_wgs84)
crs(rast_male_relativebodybreadth_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_male_relativebodybreadth_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_male_relativebodybreadth_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_male_relativebodybreadth_coordonly_z_plot) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# Plot the residual spatial pattern in predicted male relative body breadth (z-scored)
plot_male_relativebodybreadth_coordonly_z_late_urban <- ggplot(df_male_relativebodybreadth_coordonly_z_plot, 
                                                    aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = male_colors_z,             # your custom color palette
    limits = z_limits,  # appropriate limits for RelativeBodyBreadth z-scores
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_male_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Male Relative Body Breadth (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(plot_male_relativebodybreadth_coordonly_z_late_urban)
```


### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_male_RelativeBodyBreadth_z <- extended_grid_male_relativebodybreadth %>%
 dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_full = RelativeBodyBreadth_pred_z
) %>%
  inner_join(
    df_male_relativebodybreadth_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_coordonly = RelativeBodyBreadth_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RelativeBodyBreadth_z_full - RelativeBodyBreadth_z_coordonly
  )

comparison_male_RelativeBodyBreadth_z <- comparison_male_RelativeBodyBreadth_z  %>%
  filter(!is.na(RelativeBodyBreadth_z_full) & !is.na(RelativeBodyBreadth_z_coordonly) & !is.na(Env_effect))


# 1. Build individual rasters
r_full_male_rbb <- rasterFromXYZ(comparison_male_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_full")])
r_coord_male_rbb  <- rasterFromXYZ(comparison_male_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_coordonly")])
r_env_male_rbb    <- rasterFromXYZ(comparison_male_RelativeBodyBreadth_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_male_rbb <- stack(r_full_male_rbb, r_coord_male_rbb, r_env_male_rbb)
names(r_stack_male_rbb) <- c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect")
r_stack_masked_male_rbb <- mask(r_stack_male_rbb, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_male_rbb <- as.data.frame(rasterToPoints(r_stack_masked_male_rbb)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_male_RelativeBodyBreadth_z_masked <- df_masked_male_rbb %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_male_relativeBodyBreadth_long_z_masked <- comparison_male_RelativeBodyBreadth_z_masked  %>%
  pivot_longer(c(RelativeBodyBreadth_z_full, RelativeBodyBreadth_z_coordonly, Env_effect),
               names_to="Model", values_to="RelativeBodyBreadth_z") %>%
  mutate(Model = factor(Model,
    levels = c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_male_rbb_late_urban <- ggplot(comparison_male_relativeBodyBreadth_long_z_masked , 
                     aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = male_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
    # Add original sites as points
  geom_point(data = modern_male_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  )+
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_male_rbb_late_urban
```

### Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_male_rbb <- conditional_effects(fit_modern_male_relativebodybreadth_scaled, effects = "altitude_scaled")
p_altitude_male_rbb <- plot(ce_altitude_male_rbb, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_male_rbb <- min(modern_male_rbb$altitude_scaled, na.rm = TRUE)
altitude_max_male_rbb <- max(modern_male_rbb$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_male_rbb <- p_altitude_male_rbb +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.85, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.85, linetype = "dotted", color = "blue") +
  annotate(    "text", x = 2, y = max(p_altitude_male_rbb$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  geom_jitter(
    data       = modern_male_rbb,
   mapping  = aes(x = altitude_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  # Range markers
  geom_vline(xintercept = altitude_min_male_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_male_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_male_rbb, y = Inf, 
           label = paste("Min =", round(altitude_min_male_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_male_rbb, y = Inf, 
           label = paste("Max =", round(altitude_max_male_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Relative Body Breadth (Z-score)"
  )

print(p_altitude_jitter_ticks_male_rbb)

modern_male_rbb %>%
  filter(altitude_scaled > 1.85)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_male_rbb <- conditional_effects(fit_modern_male_relativebodybreadth_scaled, effects = "mintemp_scaled")
p_mintemp_male_rbb <- plot(ce_mintemp_male_rbb, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_male_rbb  <- min(modern_male_rbb$mintemp_scaled, na.rm = TRUE)
temp_max_male_rbb <- max(modern_male_rbb$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_male_rbb <- p_mintemp_male_rbb +
  geom_jitter(
    data     = modern_male_rbb,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1) ,
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = temp_min_male_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_male_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_male_rbb, y = Inf, label = paste("Min =", round(temp_min_male_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_male_rbb, y = Inf, label = paste("Max =", round(temp_max_male_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Relative Body Breadth (Z-score)"
  ) 

print(p_mintemp_updated_male_rbb)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_male_rbb <- conditional_effects(fit_modern_male_relativebodybreadth_scaled, effects = "maxtemp_scaled")
p_maxtemp_male_rbb <- plot(ce_maxtemp_male_rbb, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_male_rbb <- min(modern_male_rbb$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_male_rbb <- max(modern_male_rbb$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_male_rbb <- p_maxtemp_male_rbb +
  geom_jitter(
    data = modern_male_rbb,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxtemp_min_male_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_male_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_male_rbb, y = Inf, label = paste("Min =", round(maxtemp_min_male_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_male_rbb, y = Inf, label = paste("Max =", round(maxtemp_max_male_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Relative Body Breadth (Z-score)"
  ) 

print(p_maxtemp_updated_male_rbb)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_male_rbb <- conditional_effects(fit_modern_male_relativebodybreadth_scaled, effects = "minprecip_scaled")
p_minprecip_male_rbb <- plot(ce_minprecip_male_rbb, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_male_rbb <- min(modern_male_rbb$minprecip_scaled, na.rm = TRUE)
minprecip_max_male_rbb <- max(modern_male_rbb$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_male_rbb <- p_minprecip_male_rbb +
  geom_jitter(
    data = modern_male_rbb,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = minprecip_min_male_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_male_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_male_rbb, y = Inf, label = paste("Min =", round(minprecip_min_male_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_male_rbb, y = Inf, label = paste("Max =", round(minprecip_max_male_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Relative Body Breadth (Z-score)"
  )
print(p_minprecip_updated_male_rbb)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r, warning=FALSE}
ce_maxprecip_male_rbb <- conditional_effects(fit_modern_male_relativebodybreadth_scaled, effects = "maxprecip_scaled")
p_maxprecip_male_rbb <- plot(ce_maxprecip_male_rbb, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_male_rbb <- min(modern_male_rbb$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_male_rbb <- max(modern_male_rbb$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_male_rbb <- p_maxprecip_male_rbb +
  geom_jitter(
    data = modern_male_rbb,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxprecip_min_male_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_male_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_male_rbb, y = Inf, label = paste("Min =", round(maxprecip_min_male_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_male_rbb, y = Inf, label = paste("Max =", round(maxprecip_max_male_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Relative Body Breadth (Z-score)"
  )
print(p_maxprecip_updated_male_rbb)
```

#### Check the extereme cases
```{r}
modern_male_rbb %>%
  filter(mintemp_scaled > 1.5)
modern_male_rbb %>%
  filter(mintemp_scaled < - 2)
modern_male_rbb %>%
  filter(maxtemp_scaled > 1)
modern_male_rbb %>%
  filter(maxtemp_scaled < - 3)
modern_male_rbb %>%
  filter(minprecip_scaled > 3)
modern_male_rbb %>%
  filter(minprecip_scaled < 0)
modern_male_rbb%>%
  filter(maxprecip_scaled > 3)
modern_male_rbb %>%
  filter(maxprecip_scaled < -1)
```



# Female Stature
```{r}
modern_female_stature <- female_data %>%
  filter(!is.na(Stature)) %>%
	  mutate(
		     longitude_scaled  = as.numeric(scale(Longitude)[,1]),
		         latitude_scaled   = as.numeric(scale(Latitude)[,1]),
		         mintemp_scaled    = as.numeric(scale(Mintemp)[,1]),
			     maxtemp_scaled    = as.numeric(scale(Maxtemp)[,1]),
			     minprecip_scaled  = as.numeric(scale(Minprecip)[,1]),
			         maxprecip_scaled  = as.numeric(scale(Maxprecip)[,1]),
			         altitude_scaled  = as.numeric(scale(Altitude)[,1]),
			         stature_z         = as.numeric(scale(Stature)[,1]))
sd(modern_female_stature$Stature)
```

## Fit the model
```{r}
female_stature_formula_altitude_abs_z <- bf(
  stature_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_female_stature_altitude_abs_z <- brm(
  formula = female_stature_formula_altitude_abs_z,
  data = modern_female_stature,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 8000, warmup = 2000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

# Print model summary
summary(fit_modern_female_stature_altitude_abs_z)
```

## Extract posterior draws
```{r, warning=FALSE}
# Extract posterior draws
post_draws_female_stature_z <- as_draws_df(fit_modern_female_stature_altitude_abs_z)

# Extract fixed effects (parameters starting with "b_")
fixef_female_stature_z <- post_draws_female_stature_z[, grepl("^b_", colnames(post_draws_female_stature_z))]

# Remove intercept
fixef_female_stature_no_int <- fixef_female_stature_z[, !grepl("Intercept", colnames(fixef_female_stature_z))]

# Extract random effects
raneff_female_stature_z <- post_draws_female_stature_z[, grepl("^r_Langsubgroup", colnames(post_draws_female_stature_z))]
```

## Plot posterior distributions
```{r}
# 1) Compute means
fixed_female_stature_z <- colnames(fixef_female_stature_no_int)
means_female_stature_z <- apply(fixef_female_stature_no_int, 2, mean)
means_female_stature_df_z <- data.frame(
  parameter = fixed_female_stature_z,
  mean      = means_female_stature_z,
  stringsAsFactors = FALSE
)

# 2) Clean both the draw‐matrix and the means df
colnames(fixef_female_stature_no_int) <- clean_labels(colnames(fixef_female_stature_no_int))
means_female_stature_df_z$parameter   <- clean_labels(means_female_stature_df_z$parameter)

# 3) Plot
p_fixed_female_stature_z <- mcmc_areas_ridges(
  fixef_female_stature_no_int,
  regex_pars = ".*",
  prob       = 0.95
) +
  labs(
    title = "Female Stature",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8) +
  geom_point(
    data     = means_female_stature_df_z,
    aes(x = mean, y = parameter),
    shape    = 124, size = 3, color = "blue",
    position = position_nudge(y = 0.5)
  )

# Display plot
p_fixed_female_stature_z

```

### Random density plot
```{r}
random_intercept_female_stature_z <- grep(
  "Intercept", 
  colnames(raneff_female_stature_z), 
  value = TRUE
)
random_slope_female_stature_z <- grep("TimeLate", colnames(raneff_female_stature_z), value = TRUE)
random_slope_female_stature_z <- random_slope_female_stature_z[!grepl("Austronesian", random_slope_female_stature_z)]


# 5a) Plot random intercepts for female stature
p_random_intercepts_female_stature_z <- mcmc_areas(
  raneff_female_stature_z,
  pars = random_intercept_female_stature_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Female Stature Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5b) Plot random slopes for TimeLate
p_random_slopes_female_stature_z <- mcmc_areas(
  raneff_female_stature_z,
  pars = random_slope_female_stature_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Female Stature Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 6) Print them side‐by‐side (or separately)
(p_random_intercepts_female_stature_z | p_random_slopes_female_stature_z) +
  plot_layout(ncol = 2) &
  theme(plot.margin = margin(5, 5, 5, 5))
```


## Full Prediction for Female Stature (Early Rural)---
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved female parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female stature using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_stature_altitude_abs_z,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Stature_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_stature_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_stature_z,
  file = here("output", "final_female_stature_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female stature complete and saved.\n")
```


## Full Prediction for Female Stature (Late Urban)---
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using saved female parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female stature using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_stature_altitude_abs_z,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Stature_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_stature_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_stature_z,
  file = here("output", "final_female_stature_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female stature complete and saved.\n")
```


### Coordinate-only Prediction for Female Stature (Early Rural)---
```{r}
# Create geographic grid (if not already created)
grid_female_stature_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_stature_coordonly, 
                            cut(seq_len(nrow(grid_female_stature_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved female parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored female stature using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_stature_altitude_abs_z,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Stature_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_stature_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_stature_coordonly_z,
          file = here("output", "female_stature_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female stature complete!\n")

```


### Coordinate-only Prediction for Female Stature (Late Urban)---
```{r}
# Create geographic grid (if not already created)
grid_female_stature_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_stature_coordonly, 
                            cut(seq_len(nrow(grid_female_stature_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using saved female parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored female stature using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_stature_altitude_abs_z,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Stature_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_stature_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_stature_coordonly_z,
          file = here("output", "female_stature_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female stature complete!\n")

```


###------ Early Rural-------
## Visualization for Full Prediction of Female Stature (Early Rural)
```{r}
# 1. Read the predicted female stature (z-scores)
extended_grid_female_stature <- read.csv(here("output", "final_male_stature_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_female_stature)

# 2. (Optional) Convert z-scores back to raw stature using the original mean and SD from modern_female_stature
stature_mean <- mean(modern_female_stature$Stature, na.rm = TRUE)
stature_sd   <- sd(modern_female_stature$Stature, na.rm = TRUE)

extended_grid_female_stature <- extended_grid_female_stature %>%
  mutate(Stature_raw = Stature_pred_z * stature_sd + stature_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_stature <- extended_grid_female_stature %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Stature_z   = mean(Stature_pred_z, na.rm = TRUE),
    Stature_raw = mean(Stature_raw, na.rm = TRUE)  # optional raw value
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_stature <- rasterFromXYZ(spatial_trends_female_stature[, c("Longitude", "Latitude", "Stature_z")])
rast_z_female_stature <- mask(rast_z_female_stature, basemap_sp_wgs84)
crs(rast_z_female_stature) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_stature <- as.data.frame(rasterToPoints(rast_z_female_stature), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_stature) <- c("Longitude", "Latitude", "Stature_z")

# 6. Plot the spatial trends of predicted female stature (z-scored)
p_spatial_trends_z_female_stature_early_rural <- ggplot(spatial_trends_z_female_stature, aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,      # define a female-specific color palette (e.g., from viridis)
    limits = z_limits,  # set limits appropriate for female stature z-scores, e.g., c(-2,2)
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Stature (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_female_stature_early_rural)
```

### Visualization for Coordinate-only Prediction of Female Stature (Early Rural)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_stature_coordonly_z <- read.csv(here("output", "final_female_stature_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(df_female_stature_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_stature_coordonly_z)[colnames(df_female_stature_coordonly_z) == "Stature_pred_z"] <- "Stature_z"

# Convert to raster using Longitude, Latitude, and Stature_z
rast_female_stature_coordonly_z <- rasterFromXYZ(
  df_female_stature_coordonly_z[, c("Longitude", "Latitude", "Stature_z")]
)

# Mask the raster with the basemap shapefile
rast_female_stature_coordonly_z <- mask(rast_female_stature_coordonly_z, basemap_sp_wgs84)
crs(rast_female_stature_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_female_stature_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_stature_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_stature_coordonly_z_plot) <- c("Longitude", "Latitude", "Stature_z")

# Plot the residual spatial pattern in predicted female stature (z-scored)
p_female_stature_coordonly_z_early_rural <- ggplot(df_female_stature_coordonly_z_plot, 
                                       aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,             # female-specific color palette
    limits = z_limits,       # limits for female stature z-scores, e.g., c(-2, 2)
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Stature (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(p_female_stature_coordonly_z_early_rural)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_stature_z <- extended_grid_female_stature %>%
 dplyr::select(Longitude, Latitude, Stature_z_full = Stature_pred_z) %>%
  inner_join(
    df_female_stature_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Stature_z_coordonly = Stature_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Stature_z_full - Stature_z_coordonly
  )
comparison_female_stature_z <- comparison_female_stature_z %>%
  filter(!is.na(Stature_z_full) & !is.na(Stature_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_stature   <- rasterFromXYZ(comparison_female_stature_z[, c("Longitude","Latitude","Stature_z_full")])
r_coord_female_stature  <- rasterFromXYZ(comparison_female_stature_z[, c("Longitude","Latitude","Stature_z_coordonly")])
r_env_female_stature    <- rasterFromXYZ(comparison_female_stature_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_stature <- stack(r_full_female_stature, r_coord_female_stature, r_env_female_stature)
names(r_stack_female_stature) <- c("Stature_z_full","Stature_z_coordonly","Env_effect")
r_stack_masked_female_stature <- mask(r_stack_female_stature, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_stature <- as.data.frame(rasterToPoints(r_stack_masked_female_stature)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_stature_z_masked <- df_masked_female_stature %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_stature_long_z_masked <- comparison_female_stature_z_masked %>%
  pivot_longer(c(Stature_z_full, Stature_z_coordonly, Env_effect),
               names_to="Model", values_to="Stature_z") %>%
  mutate(Model = factor(Model,
    levels = c("Stature_z_full","Stature_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_female_stature_comparison_z_early_rural <- ggplot(comparison_female_stature_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
     # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
     scale_x_continuous(
      breaks = seq(70, 140, by = 20))+
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_text(size = 7, face = "bold"),
    plot.title = element_text(size = 7, face = "bold"),
    axis.title = element_text(size = 7),
    axis.text = element_text(size = 7),
    legend.title = element_text(size = 7),
    legend.text = element_text(size = 7)
  )

p_female_stature_comparison_z_early_rural
```

###------ Late Urban-------
## Visualization for Full Prediction of Female Stature (Late Urban)
```{r}
# 1. Read the predicted female stature (z-scores)
extended_grid_female_stature <- read.csv(here("output", "final_female_stature_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_female_stature)

# 2. (Optional) Convert z-scores back to raw stature using the original mean and SD from modern_female_stature
stature_mean <- mean(modern_female_stature$Stature, na.rm = TRUE)
stature_sd   <- sd(modern_female_stature$Stature, na.rm = TRUE)

extended_grid_female_stature <- extended_grid_female_stature %>%
  mutate(Stature_raw = Stature_pred_z * stature_sd + stature_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_stature <- extended_grid_female_stature %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Stature_z   = mean(Stature_pred_z, na.rm = TRUE),
    Stature_raw = mean(Stature_raw, na.rm = TRUE)  # optional raw value
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_stature <- rasterFromXYZ(spatial_trends_female_stature[, c("Longitude", "Latitude", "Stature_z")])
rast_z_female_stature <- mask(rast_z_female_stature, basemap_sp_wgs84)
crs(rast_z_female_stature) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_stature <- as.data.frame(rasterToPoints(rast_z_female_stature), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_stature) <- c("Longitude", "Latitude", "Stature_z")

# 6. Plot the spatial trends of predicted female stature (z-scored)
p_spatial_trends_z_female_stature_late_urban <- ggplot(spatial_trends_z_female_stature, aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,      # define a female-specific color palette (e.g., from viridis)
    limits = z_limits,  # set limits appropriate for female stature z-scores, e.g., c(-2,2)
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Stature (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_female_stature_late_urban)
```

### Visualization for Coordinate-only Prediction of Female Stature (Late Urban)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_stature_coordonly_z <- read.csv(here("output", "female_stature_pred_coordonly_chunks_z_late_urban.csv"))
head(df_female_stature_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_stature_coordonly_z)[colnames(df_female_stature_coordonly_z) == "Stature_pred_z"] <- "Stature_z"

# Convert to raster using Longitude, Latitude, and Stature_z
rast_female_stature_coordonly_z <- rasterFromXYZ(
  df_female_stature_coordonly_z[, c("Longitude", "Latitude", "Stature_z")]
)

# Mask the raster with the basemap shapefile
rast_female_stature_coordonly_z <- mask(rast_female_stature_coordonly_z, basemap_sp_wgs84)
crs(rast_female_stature_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_female_stature_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_stature_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_stature_coordonly_z_plot) <- c("Longitude", "Latitude", "Stature_z")

# Plot the residual spatial pattern in predicted female stature (z-scored)
p_female_stature_coordonly_z_late_urban <- ggplot(df_female_stature_coordonly_z_plot, 
                                       aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,             # female-specific color palette
    limits = z_limits,       # limits for female stature z-scores, e.g., c(-2, 2)
    name = "Stature (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Stature (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(p_female_stature_coordonly_z_late_urban)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_stature_z <- extended_grid_female_stature %>%
 dplyr::select(Longitude, Latitude, Stature_z_full = Stature_pred_z) %>%
  inner_join(
    df_female_stature_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Stature_z_coordonly = Stature_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Stature_z_full - Stature_z_coordonly
  )
comparison_female_stature_z <- comparison_female_stature_z %>%
  filter(!is.na(Stature_z_full) & !is.na(Stature_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_stature   <- rasterFromXYZ(comparison_female_stature_z[, c("Longitude","Latitude","Stature_z_full")])
r_coord_female_stature  <- rasterFromXYZ(comparison_female_stature_z[, c("Longitude","Latitude","Stature_z_coordonly")])
r_env_female_stature    <- rasterFromXYZ(comparison_female_stature_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_stature <- stack(r_full_female_stature, r_coord_female_stature, r_env_female_stature)
names(r_stack_female_stature) <- c("Stature_z_full","Stature_z_coordonly","Env_effect")
r_stack_masked_female_stature <- mask(r_stack_female_stature, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_stature <- as.data.frame(rasterToPoints(r_stack_masked_female_stature)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_stature_z_masked <- df_masked_female_stature %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_stature_long_z_masked <- comparison_female_stature_z_masked %>%
  pivot_longer(c(Stature_z_full, Stature_z_coordonly, Env_effect),
               names_to="Model", values_to="Stature_z") %>%
  mutate(Model = factor(Model,
    levels = c("Stature_z_full","Stature_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_female_stature_comparison_z_late_urban <- ggplot(comparison_female_stature_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
     # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
     scale_x_continuous(
      breaks = seq(70, 140, by = 20))+
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_text(size = 7, face = "bold"),
    plot.title = element_text(size = 7, face = "bold"),
    axis.title = element_text(size = 7),
    axis.text = element_text(size = 7),
    legend.title = element_text(size = 7),
    legend.text = element_text(size = 7)
  )

p_female_stature_comparison_z_late_urban
```


#### take only the Env_effect panel
```{r}
env_df_female_stature <- comparison_female_stature_long_z_masked %>%
  filter(Model == "C) Environmental Effect (Full–Coordonly)")

# plot just that
p_env_female_stature <- ggplot(env_df_female_stature, aes(x = Longitude, y = Latitude, fill = Stature_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "Female stature\n(z-score)",
    na.value = "transparent"
  ) +
  geom_point(data = modern_female_stature, 
             aes(x = Longitude, y = Latitude),
             size = 0.3, shape = 24, fill = "red", color = "red", stroke = 0.1) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "C) Environmental Effect (Full – Coordonly)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal(base_size = 8) +
  theme(
    plot.title   = element_text(size = 8, face = "bold"),
    axis.title   = element_text(size = 7),
    axis.text    = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.text  = element_text(size = 6)
  )

p_env_female_stature
```

#### Highlighting environmental effets
```{r}
p_env_effect_masked_female_stature <- ggplot(comparison_female_stature_z_masked, 
                              aes(x = Longitude, y = Latitude)) +
  geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
  geom_raster(data = subset(comparison_female_stature_z_masked, Env_effect_category == "Weak"), 
              fill = "grey90") +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "Environmental\nEffect (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
       # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "D) Environmental Effect (Masked by Strength)",
    subtitle = "Gray = Weak Effect (|z| < 0.3)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    plot.title = element_text(size = 6, face = "bold"),
    plot.subtitle = element_text(size = 6),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_env_effect_masked_female_stature
```


```{r, warning=FALSE}
for (threshold in c(0.1, 0.3, 0.5)) {
  cat("Threshold:", threshold, "\n")
  
  tmp_df <- comparison_female_stature_z_masked %>%
    mutate(Env_effect_category = if_else(abs(Env_effect) >= threshold, "Strong", "Weak"))
  
  p_tmp <- ggplot(tmp_df, aes(x = Longitude, y = Latitude)) +
    geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
    geom_raster(data = subset(tmp_df, Env_effect_category == "Weak"),
                fill = "grey90") +
    scale_fill_gradientn(
      colors = female_colors_z, limits = z_limits, na.value = "transparent",
      name = "Environmental\nEffect (z-score)"
    ) +
     # Add original sites as points
  geom_point(data = modern_female_stature, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    ggtitle(paste0("Environmental Effect (Threshold ", threshold, ")")) +
    theme_minimal()
  
  print(p_tmp)
}
```

###Conditional Effect - separated
#### Conditional Effect for Altitude
```{r}
# Extract conditional effect
ce_altitude_female_stature <- conditional_effects(fit_modern_female_stature_altitude_abs_z, effects = "altitude_scaled")
p_altitude_female_stature <- plot(ce_altitude_female_stature, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_female_stature <- min(modern_female_stature$altitude_scaled, na.rm = TRUE)
altitude_max_female_stature <- max(modern_female_stature$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_female_stature <- p_altitude_female_stature +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.6, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.6, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_female_stature$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  # —— bottom-only “ticks” using geom_jitter() ——  
  geom_jitter(
    data     = modern_female_stature,
    mapping  = aes(x = altitude_scaled, y = -Inf), # anchor at bottom
    inherit.aes = FALSE,
    shape    = 124,                               # vertical bar “|”
    size     = 3,                                 # thickness of the tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show

  # Range markers
  geom_vline(xintercept = altitude_min_female_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_female_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_female_stature, y = Inf, 
           label = paste("Min =", round(altitude_min_female_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_female_stature, y = Inf, 
           label = paste("Max =", round(altitude_max_female_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Stature (Z‑score)"
  )

print(p_altitude_jitter_ticks_female_stature)

modern_female_stature %>%
  filter(altitude_scaled > 1.6)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r}
ce_mintemp_female_stature <- conditional_effects(fit_modern_female_stature_altitude_abs_z, effects = "mintemp_scaled")
p_mintemp_female_stature <- plot(ce_mintemp_female_stature, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_female_stature <- min(modern_female_stature$mintemp_scaled, na.rm = TRUE)
temp_max_female_stature <- max(modern_female_stature$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_female_stature <- p_mintemp_female_stature +
  geom_jitter(
    data     = modern_female_stature,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"     
  )  +
  geom_vline(xintercept = temp_min_female_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_female_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_female_stature, y = Inf, label = paste("Min =", round(temp_min_female_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_female_stature, y = Inf, label = paste("Max =", round(temp_max_female_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Stature (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_mintemp_updated_female_stature)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_female_stature <- conditional_effects(fit_modern_female_stature_altitude_abs_z, effects = "maxtemp_scaled")
p_maxtemp_female_stature <- plot(ce_maxtemp_female_stature, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_female_stature <- min(modern_female_stature$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_female_stature <- max(modern_female_stature$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_female_stature <- p_maxtemp_female_stature +
  geom_jitter(
    data = modern_female_stature,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxtemp_min_female_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_female_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_female_stature, y = Inf, label = paste("Min =", round(maxtemp_min_female_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_female_stature, y = Inf, label = paste("Max =", round(maxtemp_max_female_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Stature (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxtemp_updated_female_stature)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_female_stature <- conditional_effects(fit_modern_female_stature_altitude_abs_z, effects = "minprecip_scaled")
p_minprecip_female_stature <- plot(ce_minprecip_female_stature, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_female_stature <- min(modern_female_stature$minprecip_scaled, na.rm = TRUE)
minprecip_max_female_stature <- max(modern_female_stature$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_female_stature <- p_minprecip_female_stature +
  geom_jitter(
    data = modern_female_stature,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = minprecip_min_female_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_female_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_female_stature, y = Inf, label = paste("Min =", round(minprecip_min_female_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_female_stature, y = Inf, label = paste("Max =", round(minprecip_max_female_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Stature (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible
print(p_minprecip_updated_female_stature)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r}
ce_maxprecip_female_stature <- conditional_effects(fit_modern_female_stature_altitude_abs_z, effects = "maxprecip_scaled")
p_maxprecip_female_stature <- plot(ce_maxprecip_female_stature, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_female_stature <- min(modern_female_stature$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_female_stature <- max(modern_female_stature$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_female_stature <- p_maxprecip_female_stature +
  geom_jitter(
    data = modern_female_stature,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxprecip_min_female_stature, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_female_stature, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_female_stature, y = Inf, label = paste("Min =", round(maxprecip_min_female_stature, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_female_stature, y = Inf, label = paste("Max =", round(maxprecip_max_female_stature, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Stature (Z-score)"
  )+
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxprecip_updated_female_stature)
```

#### Check the extereme cases
```{r}
modern_female_stature %>%
  filter(mintemp_scaled > 1.5)
modern_female_stature %>%
  filter(mintemp_scaled < - 2)
modern_female_stature %>%
  filter(maxtemp_scaled > 1)
modern_female_stature %>%
  filter(maxtemp_scaled < - 3)
modern_female_stature %>%
  filter(minprecip_scaled > 3)
modern_female_stature %>%
  filter(minprecip_scaled < 0)
modern_female_stature %>%
  filter(maxprecip_scaled > 3)
modern_female_stature %>%
  filter(maxprecip_scaled < -1)
```


# Female body mass
```{r}
modern_female_bodymass <- female_data %>%
  filter(!is.na(Bodymass)) %>%
             mutate(
                            Bodymass   = as.numeric(Bodymass),
                                longitude_scaled  = as.numeric(scale(Longitude)[,1]),
                                latitude_scaled   = as.numeric(scale(Latitude)[,1]),
                                    mintemp_scaled    = as.numeric(scale(Mintemp)[,1]),
                                    maxtemp_scaled    = as.numeric(scale(Maxtemp)[,1]),
                                    minprecip_scaled  = as.numeric(scale(Minprecip)[,1]),
                                    maxprecip_scaled  = as.numeric(scale(Maxprecip)[,1]),
                                    altitude_scaled  = as.numeric(scale(Altitude)[,1]),
                                    Bodymass_z        = as.numeric(scale(Bodymass)[,1])
                                         )

mean(modern_female_bodymass$Bodymass, na.rm = TRUE)
sd(modern_female_bodymass$Bodymass, na.rm = TRUE)
```


```{r}
female_bodymass_formula_scaled <- bf(
  Bodymass_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_female_bodymass_scaled <- brm(
  formula = female_bodymass_formula_scaled,
  data = modern_female_bodymass,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

summary(fit_modern_female_bodymass_scaled)
```

## Extract posterior draws
```{r}
# Extract posterior draws
post_draws_female_bodymass_z <- as_draws_df(fit_modern_female_bodymass_scaled)

# Extract fixed effects (parameters starting with "b_")
fixef_female_bodymass_z <- post_draws_female_bodymass_z[, grepl("^b_", colnames(post_draws_female_bodymass_z))]

# Remove intercept
fixef_female_bodymass_no_int <- fixef_female_bodymass_z[, !grepl("Intercept", colnames(fixef_female_bodymass_z))]

# Extract random effects
raneff_female_bodymass_z <- post_draws_female_bodymass_z[, grepl("^r_Langsubgroup", colnames(post_draws_female_bodymass_z))]

```

## Plot posterior distributions
```{r}
# 1) Compute means
fixed_female_bodymass_z <- colnames(fixef_female_bodymass_no_int)
means_female_bodymass_z <- apply(fixef_female_bodymass_no_int, 2, mean)
means_female_bodymass_df_z <- data.frame(
  parameter = fixed_female_bodymass_z,
  mean      = means_female_bodymass_z,
  stringsAsFactors = FALSE
)

# 2) Clean column names in matrix and means df
colnames(fixef_female_bodymass_no_int)         <- clean_labels(colnames(fixef_female_bodymass_no_int))
means_female_bodymass_df_z$parameter           <- clean_labels(means_female_bodymass_df_z$parameter)

# 3) Plot
p_fixed_female_bodymass_z <- mcmc_areas_ridges(
  fixef_female_bodymass_no_int,
  regex_pars = ".*",  # match all cleaned names
  prob       = 0.95
) +
  labs(
    title = "Female Body Mass",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(
    xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8
  ) +
  geom_point(
    data     = means_female_bodymass_df_z,
    aes(x = mean, y = parameter),
    shape    = 124, size = 3, color = "blue",
    position = position_nudge(y = 0.5)
  )

# Print the plot
p_fixed_female_bodymass_z

```

### Random density plot
```{r}
# 3) Identify which columns are random intercepts vs. random slopes
random_intercept_female_bodymass_z <- grep(
  "Intercept", 
  colnames(raneff_female_bodymass_z), 
  value = TRUE
)
random_slope_female_bodymass_z <- grep("TimeLate", colnames(raneff_female_bodymass_z), value = TRUE)
random_slope_female_bodymass_z <- random_slope_female_bodymass_z[!grepl("Austronesian", random_slope_female_bodymass_z)]

# 5a) Plot random intercepts for female body mass
p_random_intercepts_female_bodymass_z <- mcmc_areas(
  raneff_female_bodymass_z,
  pars = random_intercept_female_bodymass_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Female Body Mass Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5b) Plot random slopes for TimeLate
p_random_slopes_female_bodymass_z <- mcmc_areas(
  raneff_female_bodymass_z,
  pars = random_slope_female_bodymass_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Female Body Mass Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 6) Display them side‑by‑side
(p_random_intercepts_female_bodymass_z | p_random_slopes_female_bodymass_z) +
  plot_layout(ncol = 2) &
  theme(plot.margin = margin(5, 5, 5, 5))

```

## Full Prediction for Female Body Mass 
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full female body mass model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values from each location
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using female-specific parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female body mass using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Bodymass_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_bodymass_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_bodymass_z,
  file = here("output", "final_female_bodymass_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female body mass complete and saved.\n")
```


```{r}
# 7. Save the visualization to a TIFF file
ggsave(filename = "output/female_bodymass_spatial_trends_z_with_abs_altitude_coordinates.tiff", 
       plot = p_spatial_trends_z_female_bodymass, 
       dpi = 300,
       device = "tiff",
       width = 10, height = 8, units = "in")

cat("Full prediction visualization for female body mass complete and saved!\n")
```

## Full Prediction for Female Body Mass (Late Urban)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full female body mass model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values from each location
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale environmental and spatial predictors using female-specific parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female body mass using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$Bodymass_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_bodymass_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_bodymass_z,
  file = here("output", "final_female_bodymass_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female body mass complete and saved.\n")
```

### Coordinate-only Prediction for Female Body Mass (Early Rural)
```{r}
# Create geographic grid (if not already created)
grid_female_bodymass_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_bodymass_coordonly, 
                            cut(seq_len(nrow(grid_female_bodymass_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using female-specific parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored female body mass using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$Bodymass_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_bodymass_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_bodymass_coordonly_z,
          file = here("output", "female_bodymass_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female body mass complete!\n")
```

### Coordinate-only Prediction for Female Body Mass (Late Urban)
```{r}
# Create geographic grid (if not already created)
grid_female_bodymass_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_bodymass_coordonly, 
                            cut(seq_len(nrow(grid_female_bodymass_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using female-specific parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict z-scored female body mass using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_bodymass_scaled,
    newdata = grid_chunk,
    re_formula = ~0  # fixed effects only
  )
  
  grid_chunk$Bodymass_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_bodymass_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_bodymass_coordonly_z,
          file = here("output", "female_bodymass_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female body mass complete!\n")
```

###------ Early Rural-------
### Visualization for Full Prediction of Female Body Mass (Early-Rural)-
```{r}
# 1. Read the predicted female body mass (z-scores)
extended_grid_female_bodymass <- read.csv(here("output", "final_female_bodymass_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_female_bodymass)

# 2. (Optional) Convert z-scores back to raw body mass using the original mean and SD from modern_female_bodymass
bodymass_mean <- mean(modern_female_bodymass$Bodymass, na.rm = TRUE)
bodymass_sd   <- sd(modern_female_bodymass$Bodymass, na.rm = TRUE)

extended_grid_female_bodymass <- extended_grid_female_bodymass %>%
  mutate(Bodymass_raw = Bodymass_pred_z * bodymass_sd + bodymass_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_bodymass <- extended_grid_female_bodymass %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Bodymass_z   = mean(Bodymass_pred_z, na.rm = TRUE),
    Bodymass_raw = mean(Bodymass_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_bodymass <- rasterFromXYZ(spatial_trends_female_bodymass[, c("Longitude", "Latitude", "Bodymass_z")])
rast_z_female_bodymass <- mask(rast_z_female_bodymass, basemap_sp_wgs84)
crs(rast_z_female_bodymass) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_bodymass <- as.data.frame(rasterToPoints(rast_z_female_bodymass), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_bodymass) <- c("Longitude", "Latitude", "Bodymass_z")

# 6. Plot the spatial trends of predicted female body mass (z-scored)
p_spatial_trends_z_female_bodymass_early_rural <- ggplot(spatial_trends_z_female_bodymass, aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
 # Add original sites as points
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  scale_fill_gradientn(
    colors = female_colors_z,           # specify your female color palette (e.g., from viridis)
    limits = z_limits,    # set appropriate limits, e.g., c(-2, 2)
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Body Mass (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_female_bodymass_early_rural)
```

### Visualization for Coordinate-only Prediction of Female Body Mass (Early Rural)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_bodymass_coordonly_z <- read.csv(here("output", "female_bodymass_pred_coordonly_chunks_z_early_rural.csv"))
head(df_female_bodymass_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_bodymass_coordonly_z)[colnames(df_female_bodymass_coordonly_z) == "Bodymass_pred_z"] <- "Bodymass_z"

# Convert to raster using Longitude, Latitude, and Bodymass_z
rast_female_bodymass_coordonly_z <- rasterFromXYZ(
  df_female_bodymass_coordonly_z[, c("Longitude", "Latitude", "Bodymass_z")]
)

# Mask the raster with the basemap shapefile
rast_female_bodymass_coordonly_z <- mask(rast_female_bodymass_coordonly_z, basemap_sp_wgs84)
crs(rast_female_bodymass_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_female_bodymass_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_bodymass_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_bodymass_coordonly_z_plot) <- c("Longitude", "Latitude", "Bodymass_z")

# Plot the residual spatial pattern in predicted female body mass (z-scored)
p_female_bodymass_coordonly_z_early_rural <- ggplot(df_female_bodymass_coordonly_z_plot, 
                                        aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,           # female-specific color palette
    limits = z_limits,    # set appropriate limits, e.g., c(-2, 2)
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Body Mass (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(p_female_bodymass_coordonly_z_early_rural)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_bodymass_z <- extended_grid_female_bodymass %>%
 dplyr::select(Longitude, Latitude, Bodymass_z_full = Bodymass_pred_z) %>%
  inner_join(
    df_female_bodymass_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Bodymass_z_coordonly = Bodymass_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Bodymass_z_full - Bodymass_z_coordonly
  )

comparison_female_bodymass_z <- comparison_female_bodymass_z  %>%
  filter(!is.na(Bodymass_z_full) & !is.na(Bodymass_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_bodymass   <- rasterFromXYZ(comparison_female_bodymass_z[, c("Longitude","Latitude","Bodymass_z_full")])
r_coord_female_bodymass  <- rasterFromXYZ(comparison_female_bodymass_z[, c("Longitude","Latitude","Bodymass_z_coordonly")])
r_env_female_bodymass    <- rasterFromXYZ(comparison_female_bodymass_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_bodymass <- stack(r_full_female_bodymass, r_coord_female_bodymass, r_env_female_bodymass)
names(r_stack_female_bodymass) <- c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect")
r_stack_masked_female_bodymass <- mask(r_stack_female_bodymass, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_bodymass <- as.data.frame(rasterToPoints(r_stack_masked_female_bodymass)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_bodymass_z_masked <- df_masked_female_bodymass %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_bodymass_long_z_masked <- comparison_female_bodymass_z_masked %>%
  pivot_longer(c(Bodymass_z_full, Bodymass_z_coordonly, Env_effect),
               names_to="Model", values_to="Bodymass_z") %>%
  mutate(Model = factor(Model,
    levels = c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_female_bodymass_early_rural <- ggplot(comparison_female_bodymass_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_female_bodymass_early_rural
```

###------ Late Urban-------
### Visualization for Full Prediction of Female Body Mass (Late-Urban)
```{r, warning=FALSE}
# 1. Read the predicted female body mass (z-scores)
extended_grid_female_bodymass <- read.csv(here("output", "final_female_bodymass_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_female_bodymass)

# 2. (Optional) Convert z-scores back to raw body mass using the original mean and SD from modern_female_bodymass
bodymass_mean <- mean(modern_female_bodymass$Bodymass, na.rm = TRUE)
bodymass_sd   <- sd(modern_female_bodymass$Bodymass, na.rm = TRUE)

extended_grid_female_bodymass <- extended_grid_female_bodymass %>%
  mutate(Bodymass_raw = Bodymass_pred_z * bodymass_sd + bodymass_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_bodymass <- extended_grid_female_bodymass %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    Bodymass_z   = mean(Bodymass_pred_z, na.rm = TRUE),
    Bodymass_raw = mean(Bodymass_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_bodymass <- rasterFromXYZ(spatial_trends_female_bodymass[, c("Longitude", "Latitude", "Bodymass_z")])
rast_z_female_bodymass <- mask(rast_z_female_bodymass, basemap_sp_wgs84)
crs(rast_z_female_bodymass) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_bodymass <- as.data.frame(rasterToPoints(rast_z_female_bodymass), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_bodymass) <- c("Longitude", "Latitude", "Bodymass_z")

# 6. Plot the spatial trends of predicted female body mass (z-scored)
p_spatial_trends_z_female_bodymass_late_urban <- ggplot(spatial_trends_z_female_bodymass, aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
 # Add original sites as points
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  scale_fill_gradientn(
    colors = female_colors_z,           # specify your female color palette (e.g., from viridis)
    limits = z_limits,    # set appropriate limits, e.g., c(-2, 2)
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Body Mass (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_female_bodymass_late_urban)
```

### Visualization for Coordinate-only Prediction of Female Body Mass (Late Urban)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_bodymass_coordonly_z <- read.csv(here("output", "female_bodymass_pred_coordonly_chunks_z_late_urban.csv"))
head(df_female_bodymass_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_bodymass_coordonly_z)[colnames(df_female_bodymass_coordonly_z) == "Bodymass_pred_z"] <- "Bodymass_z"

# Convert to raster using Longitude, Latitude, and Bodymass_z
rast_female_bodymass_coordonly_z <- rasterFromXYZ(
  df_female_bodymass_coordonly_z[, c("Longitude", "Latitude", "Bodymass_z")]
)

# Mask the raster with the basemap shapefile
rast_female_bodymass_coordonly_z <- mask(rast_female_bodymass_coordonly_z, basemap_sp_wgs84)
crs(rast_female_bodymass_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for ggplot2
df_female_bodymass_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_bodymass_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_bodymass_coordonly_z_plot) <- c("Longitude", "Latitude", "Bodymass_z")

# Plot the residual spatial pattern in predicted female body mass (z-scored)
p_female_bodymass_coordonly_z_late_urban <- ggplot(df_female_bodymass_coordonly_z_plot, 
                                        aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,           # female-specific color palette
    limits = z_limits,    # set appropriate limits, e.g., c(-2, 2)
    name = "Body Mass (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Body Mass (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

# Print the plot
print(p_female_bodymass_coordonly_z_late_urban)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_bodymass_z <- extended_grid_female_bodymass %>%
 dplyr::select(Longitude, Latitude, Bodymass_z_full = Bodymass_pred_z) %>%
  inner_join(
    df_female_bodymass_coordonly_z %>%
      dplyr::select(Longitude, Latitude, Bodymass_z_coordonly = Bodymass_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = Bodymass_z_full - Bodymass_z_coordonly
  )

comparison_female_bodymass_z <- comparison_female_bodymass_z  %>%
  filter(!is.na(Bodymass_z_full) & !is.na(Bodymass_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_bodymass   <- rasterFromXYZ(comparison_female_bodymass_z[, c("Longitude","Latitude","Bodymass_z_full")])
r_coord_female_bodymass  <- rasterFromXYZ(comparison_female_bodymass_z[, c("Longitude","Latitude","Bodymass_z_coordonly")])
r_env_female_bodymass    <- rasterFromXYZ(comparison_female_bodymass_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_bodymass <- stack(r_full_female_bodymass, r_coord_female_bodymass, r_env_female_bodymass)
names(r_stack_female_bodymass) <- c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect")
r_stack_masked_female_bodymass <- mask(r_stack_female_bodymass, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_bodymass <- as.data.frame(rasterToPoints(r_stack_masked_female_bodymass)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_bodymass_z_masked <- df_masked_female_bodymass %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_bodymass_long_z_masked <- comparison_female_bodymass_z_masked %>%
  pivot_longer(c(Bodymass_z_full, Bodymass_z_coordonly, Env_effect),
               names_to="Model", values_to="Bodymass_z") %>%
  mutate(Model = factor(Model,
    levels = c("Bodymass_z_full","Bodymass_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_models_z_female_bodymass_late_urban <- ggplot(comparison_female_bodymass_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = Bodymass_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_female_bodymass_late_urban
```


#### Highlighting environmental effets
```{r}
p_env_effect_masked_female_bodymass <- ggplot(comparison_female_bodymass_z_masked, 
                              aes(x = Longitude, y = Latitude)) +
  geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
  geom_raster(data = subset(comparison_female_bodymass_z_masked, Env_effect_category == "Weak"), 
              fill = "grey90") +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "Environmental\nEffect (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
       # Add original sites as points
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "D) Environmental Effect (Masked by Strength)",
    subtitle = "Gray = Weak Effect (|z| < 0.3)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    plot.title = element_text(size = 6, face = "bold"),
    plot.subtitle = element_text(size = 6),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_env_effect_masked_female_bodymass
```

```{r, warning=FALSE}
for (threshold in c(0.1, 0.3, 0.5)) {
  cat("Threshold:", threshold, "\n")
  
  tmp_df <- comparison_female_bodymass_z_masked %>%
    mutate(Env_effect_category = if_else(abs(Env_effect) >= threshold, "Strong", "Weak"))
  
  p_tmp <- ggplot(tmp_df, aes(x = Longitude, y = Latitude)) +
    geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
    geom_raster(data = subset(tmp_df, Env_effect_category == "Weak"),
                fill = "grey90") +
    scale_fill_gradientn(
      colors = female_colors_z, limits = z_limits, na.value = "transparent",
      name = "Environmental\nEffect (z-score)"
    ) +
     # Add original sites as points
  geom_point(data = modern_female_bodymass, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.5, 
             shape = 24, 
             fill = "grey", 
             color = "red", 
             stroke = 0.5,
             inherit.aes = FALSE) +
    coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    ggtitle(paste0("Environmental Effect (Threshold ", threshold, ")")) +
    theme_minimal()
  
  print(p_tmp)
}
```

### Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_female_bodymass <- conditional_effects(fit_modern_female_bodymass_scaled, effects = "altitude_scaled")
p_altitude_female_bodymass <- plot(ce_altitude_female_bodymass, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_female_bodymass <- min(modern_female_bodymass$altitude_scaled, na.rm = TRUE)
altitude_max_female_bodymass <- max(modern_female_bodymass$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_female_bodymass <- p_altitude_female_bodymass +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.56, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.56, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_female_bodymass$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  # —— bottom-only “ticks” using geom_jitter() ——  
  geom_jitter(
    data     = modern_female_bodymass,
    mapping  = aes(x = altitude_scaled, y = -Inf), # anchor at bottom
    inherit.aes = FALSE,
    shape    = 124,                               # vertical bar “|”
    size     = 3,                                 # thickness of the tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") + 
  # Range markers
  geom_vline(xintercept = altitude_min_female_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_female_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_female_bodymass, y = Inf, 
           label = paste("Min =", round(altitude_min_female_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_female_bodymass, y = Inf, 
           label = paste("Max =", round(altitude_max_female_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Body Mass (Z-score)"
  )

print(p_altitude_jitter_ticks_female_bodymass)

modern_female_bodymass %>%
  filter(altitude_scaled > 1.56)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_female_bodymass <- conditional_effects(fit_modern_female_bodymass_scaled, effects = "mintemp_scaled")
p_mintemp_female_bodymass <- plot(ce_mintemp_female_bodymass, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_female_bodymass  <- min(modern_female_bodymass$mintemp_scaled, na.rm = TRUE)
temp_max_female_bodymass <- max(modern_female_bodymass$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_female_bodymass <- p_mintemp_female_bodymass +
  geom_jitter(
    data     = modern_female_bodymass,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = temp_min_female_bodymass , linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_female_bodymass , linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_female_bodymass , y = Inf, label = paste("Min =", round(temp_min_female_bodymass , 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_female_bodymass, y = Inf, label = paste("Max =", round(temp_max_female_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Body Mass (Z-score)"
  ) 

print(p_mintemp_updated_female_bodymass)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_female_bodymass <- conditional_effects(fit_modern_female_bodymass_scaled, effects = "maxtemp_scaled")
p_maxtemp_female_bodymass <- plot(ce_maxtemp_female_bodymass, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_female_bodymass <- min(modern_female_bodymass$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_female_bodymass <- max(modern_female_bodymass$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_female_bodymass <- p_maxtemp_female_bodymass +
  geom_jitter(
    data = modern_female_bodymass,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxtemp_min_female_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_female_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_female_bodymass, y = Inf, label = paste("Min =", round(maxtemp_min_female_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_female_bodymass, y = Inf, label = paste("Max =", round(maxtemp_max_female_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Body Mass (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxtemp_updated_female_bodymass)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_female_bodymass <- conditional_effects(fit_modern_female_bodymass_scaled, effects = "minprecip_scaled")
p_minprecip_female_bodymass <- plot(ce_minprecip_female_bodymass, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_female_bodymass <- min(modern_female_bodymass$minprecip_scaled, na.rm = TRUE)
minprecip_max_female_bodymass <- max(modern_female_bodymass$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_female_bodymass <- p_minprecip_female_bodymass +
  geom_jitter(
    data = modern_female_bodymass,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = minprecip_min_female_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_female_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_female_bodymass, y = Inf, label = paste("Min =", round(minprecip_min_female_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_female_bodymass, y = Inf, label = paste("Max =", round(minprecip_max_female_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Body Mass (Z-score)"
  ) +
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible
print(p_minprecip_updated_female_bodymass)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r, warning=FALSE}
ce_maxprecip_female_bodymass <- conditional_effects(fit_modern_female_bodymass_scaled, effects = "maxprecip_scaled")
p_maxprecip_female_bodymass <- plot(ce_maxprecip_female_bodymass, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_female_bodymass <- min(modern_female_bodymass$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_female_bodymass <- max(modern_female_bodymass$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_female_bodymass <- p_maxprecip_female_bodymass +
  geom_jitter(
    data = modern_female_bodymass,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),  # only jitter in x
    clip     = "off"                                      # allow drawing on the panel edge
  ) +
  geom_vline(xintercept = maxprecip_min_female_bodymass, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_female_bodymass, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_female_bodymass, y = Inf, label = paste("Min =", round(maxprecip_min_female_bodymass, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_female_bodymass, y = Inf, label = paste("Max =", round(maxprecip_max_female_bodymass, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Body Mass (Z-score)"
  )+
  coord_cartesian(clip = "off")  # make sure the -Inf ticks are visible

print(p_maxprecip_updated_female_bodymass)
```

#### Check the extereme cases
```{r}
modern_female_bodymass %>%
  filter(mintemp_scaled > 1.5)
modern_female_bodymass %>%
  filter(mintemp_scaled < - 2)
modern_female_bodymass %>%
  filter(maxtemp_scaled > 1)
modern_female_bodymass %>%
  filter(maxtemp_scaled < - 3)
modern_female_bodymass %>%
  filter(minprecip_scaled > 3)
modern_female_bodymass %>%
  filter(minprecip_scaled < 0)
modern_female_bodymass %>%
  filter(maxprecip_scaled > 3)
modern_female_bodymass %>%
  filter(maxprecip_scaled < -1)
```


# Female relative sitting height
```{r}
modern_female_r_sittinght <- female_data %>%
  filter(!is.na(RSittinght)) %>%  # Adjust filter if needed
  mutate(
    RSittinght = as.numeric(RSittinght),
    longitude_scaled = as.numeric(scale(Longitude)[,1]),
    latitude_scaled  = as.numeric(scale(Latitude)[,1]),
    mintemp_scaled   = as.numeric(scale(Mintemp)[,1]),
    maxtemp_scaled   = as.numeric(scale(Maxtemp)[,1]),
    minprecip_scaled = as.numeric(scale(Minprecip)[,1]),
    maxprecip_scaled = as.numeric(scale(Maxprecip)[,1]),
    altitude_scaled  = as.numeric(scale(Altitude)[,1]),
    RSittinght_z     = as.numeric(scale(RSittinght)[,1])
  )

# Compute Means & SDs for RSittinght (for z-scoring predictions)
mean(modern_female_r_sittinght$RSittinght, na.rm = TRUE)
sd(modern_female_r_sittinght$RSittinght, na.rm = TRUE)
mean(modern_female_r_sittinght$Altitude, na.rm = TRUE)
sd(modern_female_r_sittinght$Altitude, na.rm = TRUE)
```


```{r}
female_r_sittinght_formula_scaled <- bf(
  RSittinght_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_female_r_sittinght_scaled <- brm(
  formula = female_r_sittinght_formula_scaled,
  data = modern_female_r_sittinght,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

summary(fit_modern_female_r_sittinght_scaled)
```

## Extract posterior draws
```{r,warning=FALSE}
# Extract posterior draws
post_draws_female_r_sittinght_z <- as_draws_df(fit_modern_female_r_sittinght_scaled)

# Extract fixed effects (parameters starting with "b_")
fixef_female_r_sittinght_z <- post_draws_female_r_sittinght_z[, grepl("^b_", colnames(post_draws_female_r_sittinght_z))]

# Remove intercept
fixef_female_r_sittinght_no_int <- fixef_female_r_sittinght_z[, !grepl("Intercept", colnames(fixef_female_r_sittinght_z))]

# Extract random effects
raneff_female_r_sittinght_z <- post_draws_female_r_sittinght_z[, grepl("^r_Langsubgroup", colnames(post_draws_female_r_sittinght_z))]
```

## Plot posterior distributions 
```{r}
# 1) Compute means
fixed_female_r_sittinght_z <- colnames(fixef_female_r_sittinght_no_int)
means_female_r_sittinght_z <- apply(fixef_female_r_sittinght_no_int, 2, mean)
means_female_r_sittinght_df_z <- data.frame(
  parameter = fixed_female_r_sittinght_z,
  mean      = means_female_r_sittinght_z,
  stringsAsFactors = FALSE
)

# 2) Clean both the draw‐matrix and the means df
colnames(fixef_female_r_sittinght_no_int)          <- clean_labels(colnames(fixef_female_r_sittinght_no_int))
means_female_r_sittinght_df_z$parameter            <- clean_labels(means_female_r_sittinght_df_z$parameter)

# 3) Plot
p_fixed_female_r_sittinght_z <- mcmc_areas_ridges(
  fixef_female_r_sittinght_no_int,
  regex_pars = ".*",
  prob       = 0.95
) +
  labs(
    title = "Female Relative Sitting Height",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.8) +
  geom_point(
    data     = means_female_r_sittinght_df_z,
    aes(x = mean, y = parameter),
    shape    = 124, size = 3, color = "blue",
    position = position_nudge(y = 0.5)
  )

# Display the plot
p_fixed_female_r_sittinght_z

```

### Random density plot
```{r}
random_intercept_female_r_sittinght_z <- grep(
  "Intercept", 
  colnames(raneff_female_r_sittinght_z), 
  value = TRUE
)
random_slope_female_r_sittinght_z <- grep("TimeLate", colnames(raneff_female_r_sittinght_z), value = TRUE)
random_slope_female_r_sittinght_z <- random_slope_female_r_sittinght_z[!grepl("Austronesian", random_slope_female_r_sittinght_z)]

# 5a) Plot random intercepts for female relative sitting height
p_random_intercepts_female_r_sittinght_z <- mcmc_areas(
  raneff_female_r_sittinght_z,
  pars = random_intercept_female_r_sittinght_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Female Relative Sitting Height Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5b) Plot random slopes for TimeLate
p_random_slopes_female_r_sittinght_z <- mcmc_areas(
  raneff_female_r_sittinght_z,
  pars = random_slope_female_r_sittinght_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Female Relative Sitting Height Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 6) Display side‐by‐side
(p_random_intercepts_female_r_sittinght_z | p_random_slopes_female_r_sittinght_z) +
  plot_layout(ncol = 2) &
  theme(plot.margin = margin(5, 5, 5, 5))

```

## Full Prediction for Female Relative Sitting Height (Early Rural)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full female relative sitting height model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      
      # Scale predictors using female-specific parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female relative sitting height using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RSittinght_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_r_sittinght_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_r_sittinght_z,
  file = here("output", "final_female_r_sittinght_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female relative sitting height complete and saved.\n")
```

## Full Prediction for Female Relative Sitting Height (Late Urban)
```{r}
# 1. Create a full geographic grid over the study area using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full female relative sitting height model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      
      # Scale predictors using female-specific parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female relative sitting height using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RSittinght_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_r_sittinght_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_r_sittinght_z,
  file = here("output", "final_female_r_sittinght_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female relative sitting height complete and saved.\n")
```

### Coordinate-only Prediction for Female Relative Sitting Height
```{r}
# Create geographic grid (if not already created)
grid_female_r_sittinght_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_r_sittinght_coordonly, 
                            cut(seq_len(nrow(grid_female_r_sittinght_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using female-specific parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled   = 0,
      maxtemp_scaled   = 0,
      minprecip_scaled = 0,
      maxprecip_scaled = 0,
      altitude_scaled  = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RSittinght_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_r_sittinght_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_r_sittinght_coordonly_z,
          file = here("output", "female_r_sittinght_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female relative sitting height complete!\n")
```


### Coordinate-only Prediction for Female Relative Sitting Height (Late Urban)
```{r}
# Create geographic grid (if not already created)
grid_female_r_sittinght_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_r_sittinght_coordonly, 
                            cut(seq_len(nrow(grid_female_r_sittinght_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using female-specific parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled   = 0,
      maxtemp_scaled   = 0,
      minprecip_scaled = 0,
      maxprecip_scaled = 0,
      altitude_scaled  = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict using the full model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_r_sittinght_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RSittinght_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_r_sittinght_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_r_sittinght_coordonly_z,
          file = here("output", "female_r_sittinght_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female relative sitting height complete!\n")
```

###------ Early Rural-------
### Visualization for Full Prediction of Female Relative Sitting Height (Early Rural)
```{r}
# 1. Read the predicted female relative sitting height (z-scores)
extended_grid_female_r_sittinght <- read.csv(here("output", "final_female_r_sittinght_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_female_r_sittinght)


# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_r_sittinght <- extended_grid_female_r_sittinght %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RSittinght_z   = mean(RSittinght_pred_z, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_r_sittinght <- rasterFromXYZ(spatial_trends_female_r_sittinght[, c("Longitude", "Latitude", "RSittinght_z")])
rast_z_female_r_sittinght <- mask(rast_z_female_r_sittinght, basemap_sp_wgs84)
crs(rast_z_female_r_sittinght) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_r_sittinght <- as.data.frame(rasterToPoints(rast_z_female_r_sittinght), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_r_sittinght) <- c("Longitude", "Latitude", "RSittinght_z")

# 6. Plot the spatial trends of predicted female relative sitting height (z-scored)
p_spatial_trends_z_female_r_sittinght_early_rural <- ggplot(spatial_trends_z_female_r_sittinght, 
                                                 aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,         # female-specific color palette
    limits = z_limits,  # e.g., c(-2, 2)
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Relative Sitting Height (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )

print(p_spatial_trends_z_female_r_sittinght_early_rural)
```

### Visualization for Coordinate-only Prediction of Female Relative Sitting Height (Early Rural)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_r_sittinght_coordonly_z <- read.csv(here("output", "female_r_sittinght_pred_coordonly_chunks_z_early_rural.csv"))
head(df_female_r_sittinght_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_r_sittinght_coordonly_z)[colnames(df_female_r_sittinght_coordonly_z) == "RSittinght_pred_z"] <- "RSittinght_z"

# Convert to raster using Longitude, Latitude, and RSittinght_z
rast_female_r_sittinght_coordonly_z <- rasterFromXYZ(
  df_female_r_sittinght_coordonly_z[, c("Longitude", "Latitude", "RSittinght_z")]
)

# Mask the raster with the basemap shapefile
rast_female_r_sittinght_coordonly_z <- mask(rast_female_r_sittinght_coordonly_z, basemap_sp_wgs84)
crs(rast_female_r_sittinght_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for plotting
df_female_r_sittinght_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_r_sittinght_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_r_sittinght_coordonly_z_plot) <- c("Longitude", "Latitude", "RSittinght_z")

# Plot the residual spatial pattern in predicted female relative sitting height (z-scored)
p_female_r_sittinght_coordonly_z_early_rural <- ggplot(df_female_r_sittinght_coordonly_z_plot, 
                                           aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,           # female-specific color palette
    limits = z_limits, # e.g., c(-2, 2)
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Relative Sitting Height (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )

print(p_female_r_sittinght_coordonly_z_early_rural)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_rsh_z <- extended_grid_female_r_sittinght %>%
 dplyr::select(Longitude, Latitude, RSittinght_z_full = RSittinght_pred_z) %>%
  inner_join(
    df_female_r_sittinght_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RSittinght_z_coordonly = RSittinght_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RSittinght_z_full - RSittinght_z_coordonly
  )

comparison_female_rsh_z <- comparison_female_rsh_z  %>%
  filter(!is.na(RSittinght_z_full) & !is.na(RSittinght_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_rsh   <- rasterFromXYZ(comparison_female_rsh_z[, c("Longitude","Latitude","RSittinght_z_full")])
r_coord_female_rsh <- rasterFromXYZ(comparison_female_rsh_z[, c("Longitude","Latitude","RSittinght_z_coordonly")])
r_env_female_rsh    <- rasterFromXYZ(comparison_female_rsh_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_rsh <- stack(r_full_female_rsh, r_coord_female_rsh, r_env_female_rsh)
names(r_stack_female_rsh) <- c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect")
r_stack_masked_female_rsh <- mask(r_stack_female_rsh, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_rsh <- as.data.frame(rasterToPoints(r_stack_masked_female_rsh)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_rsh_z_masked <- df_masked_female_rsh %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_rsh_long_z_masked <- comparison_female_rsh_z_masked %>%
  pivot_longer(c(RSittinght_z_full, RSittinght_z_coordonly, Env_effect),
               names_to="Model", values_to="RSittinght_z") %>%
  mutate(Model = factor(Model,
    levels = c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect"),
    labels = c(
      "A. Full (Space + Environment)",
      "B. Space Only",
      "C. Environment Only"
    )
  ))

p_models_z_female_rsh_early_rural <- ggplot(comparison_female_rsh_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_female_rsh_early_rural
```

###------ Late Urban-------
## Visualization for Full Prediction of Female Relative Sitting Height (Late Urban)
```{r}
# 1. Read the predicted female relative sitting height (z-scores)
extended_grid_female_r_sittinght <- read.csv(here("output", "final_female_r_sittinght_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_female_r_sittinght)


# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_r_sittinght <- extended_grid_female_r_sittinght %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RSittinght_z   = mean(RSittinght_pred_z, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_r_sittinght <- rasterFromXYZ(spatial_trends_female_r_sittinght[, c("Longitude", "Latitude", "RSittinght_z")])
rast_z_female_r_sittinght <- mask(rast_z_female_r_sittinght, basemap_sp_wgs84)
crs(rast_z_female_r_sittinght) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_r_sittinght <- as.data.frame(rasterToPoints(rast_z_female_r_sittinght), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_r_sittinght) <- c("Longitude", "Latitude", "RSittinght_z")

# 6. Plot the spatial trends of predicted female relative sitting height (z-scored)
p_spatial_trends_z_female_r_sittinght_late_urban <- ggplot(spatial_trends_z_female_r_sittinght, 
                                                 aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,         # female-specific color palette
    limits = z_limits,  # e.g., c(-2, 2)
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Relative Sitting Height (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )

print(p_spatial_trends_z_female_r_sittinght_late_urban)
```

### Visualization for Coordinate-only Prediction of Female Relative Sitting Height (Late Urban)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_r_sittinght_coordonly_z <- read.csv(here("output", "female_r_sittinght_pred_coordonly_chunks_z_late_urban.csv"))
head(df_female_r_sittinght_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_r_sittinght_coordonly_z)[colnames(df_female_r_sittinght_coordonly_z) == "RSittinght_pred_z"] <- "RSittinght_z"

# Convert to raster using Longitude, Latitude, and RSittinght_z
rast_female_r_sittinght_coordonly_z <- rasterFromXYZ(
  df_female_r_sittinght_coordonly_z[, c("Longitude", "Latitude", "RSittinght_z")]
)

# Mask the raster with the basemap shapefile
rast_female_r_sittinght_coordonly_z <- mask(rast_female_r_sittinght_coordonly_z, basemap_sp_wgs84)
crs(rast_female_r_sittinght_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for plotting
df_female_r_sittinght_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_r_sittinght_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_r_sittinght_coordonly_z_plot) <- c("Longitude", "Latitude", "RSittinght_z")

# Plot the residual spatial pattern in predicted female relative sitting height (z-scored)
p_female_r_sittinght_coordonly_z_late_urban <- ggplot(df_female_r_sittinght_coordonly_z_plot, 
                                           aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,           # female-specific color palette
    limits = z_limits, # e.g., c(-2, 2)
    name = "Relative Sitting Height (z-score)",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Relative Sitting Height (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )

print(p_female_r_sittinght_coordonly_z_late_urban)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_rsh_z <- extended_grid_female_r_sittinght %>%
 dplyr::select(Longitude, Latitude, RSittinght_z_full = RSittinght_pred_z) %>%
  inner_join(
    df_female_r_sittinght_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RSittinght_z_coordonly = RSittinght_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RSittinght_z_full - RSittinght_z_coordonly
  )

comparison_female_rsh_z <- comparison_female_rsh_z  %>%
  filter(!is.na(RSittinght_z_full) & !is.na(RSittinght_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_rsh   <- rasterFromXYZ(comparison_female_rsh_z[, c("Longitude","Latitude","RSittinght_z_full")])
r_coord_female_rsh <- rasterFromXYZ(comparison_female_rsh_z[, c("Longitude","Latitude","RSittinght_z_coordonly")])
r_env_female_rsh    <- rasterFromXYZ(comparison_female_rsh_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_rsh <- stack(r_full_female_rsh, r_coord_female_rsh, r_env_female_rsh)
names(r_stack_female_rsh) <- c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect")
r_stack_masked_female_rsh <- mask(r_stack_female_rsh, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_rsh <- as.data.frame(rasterToPoints(r_stack_masked_female_rsh)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_rsh_z_masked <- df_masked_female_rsh %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_rsh_long_z_masked <- comparison_female_rsh_z_masked %>%
  pivot_longer(c(RSittinght_z_full, RSittinght_z_coordonly, Env_effect),
               names_to="Model", values_to="RSittinght_z") %>%
  mutate(Model = factor(Model,
    levels = c("RSittinght_z_full","RSittinght_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_female_rsh_late_urban <- ggplot(comparison_female_rsh_long_z_masked, 
                     aes(x = Longitude, y = Latitude, fill = RSittinght_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_female_rsh_late_urban
```


#### Highlighting environmental effets
```{r, warning=FALSE}
p_env_effect_masked_female_rsh <- ggplot(comparison_female_rsh_z_masked, 
                              aes(x = Longitude, y = Latitude)) +
  geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
  geom_raster(data = subset(comparison_female_rsh_z_masked, Env_effect_category == "Weak"), 
              fill = "grey90") +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.8) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "Environmental\nEffect (z-score)",
    na.value = "transparent"
  ) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
       # Add original sites as points
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.3, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "D) Environmental Effect (Masked by Strength)",
    subtitle = "Gray = Weak Effect (|z| < 0.3)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    plot.title = element_text(size = 6, face = "bold"),
    plot.subtitle = element_text(size = 6),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_env_effect_masked_female_rsh
```

```{r, warning=FALSE}
for (threshold in c(0.1, 0.3, 0.5)) {
  cat("Threshold:", threshold, "\n")
  
  tmp_df <- comparison_female_rsh_z_masked %>%
    mutate(Env_effect_category = if_else(abs(Env_effect) >= threshold, "Strong", "Weak"))
  
  p_tmp <- ggplot(tmp_df, aes(x = Longitude, y = Latitude)) +
    geom_raster(aes(fill = ifelse(Env_effect_category == "Strong", Env_effect, NA))) +
    geom_raster(data = subset(tmp_df, Env_effect_category == "Weak"),
                fill = "grey90") +
    scale_fill_gradientn(
      colors = female_colors_z, limits = z_limits, na.value = "transparent",
      name = "Environmental\nEffect (z-score)"
    ) +
     # Add original sites as points
  geom_point(data = modern_female_r_sittinght, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.5, 
             shape = 24, 
             fill = "grey", 
             color = "red", 
             stroke = 0.5,
             inherit.aes = FALSE) +
    coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
    ggtitle(paste0("Environmental Effect (Threshold ", threshold, ")")) +
    theme_minimal()
  
  print(p_tmp)
}
```

### Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_female_rsh <- conditional_effects(fit_modern_female_r_sittinght_scaled, effects = "altitude_scaled")
p_altitude_female_rsh <- plot(ce_altitude_female_rsh, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_female_rsh <- min(modern_female_r_sittinght$altitude_scaled, na.rm = TRUE)
altitude_max_female_rsh <- max(modern_female_r_sittinght$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_female_rsh <- p_altitude_female_rsh +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.84, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.84, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_female_rsh$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  geom_jitter(
    data       = modern_female_r_sittinght,
   mapping  = aes(x = altitude_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  # Range markers
  geom_vline(xintercept = altitude_min_female_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_female_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_female_rsh, y = Inf, 
           label = paste("Min =", round(altitude_min_female_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_female_rsh, y = Inf, 
           label = paste("Max =", round(altitude_max_female_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Relative Sitting Height (Z-score)"
  )

print(p_altitude_jitter_ticks_female_rsh)

modern_female_r_sittinght %>%
  filter(altitude_scaled > 1.84)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_female_rsh <- conditional_effects(fit_modern_female_r_sittinght_scaled, effects = "mintemp_scaled")
p_mintemp_female_rsh <- plot(ce_mintemp_female_rsh, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_female_rsh  <- min(modern_female_r_sittinght$mintemp_scaled, na.rm = TRUE)
temp_max_female_rsh <- max(modern_female_r_sittinght$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_female_rsh <- p_mintemp_female_rsh +
  geom_jitter(
    data     = modern_female_r_sittinght,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1) ,
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = temp_min_female_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_female_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_female_rsh, y = Inf, label = paste("Min =", round(temp_min_female_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_female_rsh, y = Inf, label = paste("Max =", round(temp_max_female_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Relative Sitting Height (Z-score)"
  ) 

print(p_mintemp_updated_female_rsh)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_female_rsh <- conditional_effects(fit_modern_female_r_sittinght_scaled, effects = "maxtemp_scaled")
p_maxtemp_female_rsh <- plot(ce_maxtemp_female_rsh, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_female_rsh <- min(modern_female_r_sittinght$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_female_rsh <- max(modern_female_r_sittinght$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_female_rsh <- p_maxtemp_female_rsh +
  geom_jitter(
    data = modern_female_r_sittinght,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxtemp_min_female_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_female_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_female_rsh, y = Inf, label = paste("Min =", round(maxtemp_min_female_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_female_rsh, y = Inf, label = paste("Max =", round(maxtemp_max_female_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Relative Sitting Height (Z-score)"
  ) 

print(p_maxtemp_updated_female_rsh)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_female_rsh <- conditional_effects(fit_modern_female_r_sittinght_scaled, effects = "minprecip_scaled")
p_minprecip_female_rsh <- plot(ce_minprecip_female_rsh, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_female_rsh <- min(modern_female_r_sittinght$minprecip_scaled, na.rm = TRUE)
minprecip_max_female_rsh <- max(modern_female_r_sittinght$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_female_rsh <- p_minprecip_female_rsh +
  geom_jitter(
    data = modern_female_r_sittinght,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = minprecip_min_female_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_female_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_female_rsh, y = Inf, label = paste("Min =", round(minprecip_min_female_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_female_rsh, y = Inf, label = paste("Max =", round(minprecip_max_female_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Relative Sitting Height (Z-score)"
  )
print(p_minprecip_updated_female_rsh)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r, warning=FALSE}
ce_maxprecip_female_rsh <- conditional_effects(fit_modern_female_r_sittinght_scaled, effects = "maxprecip_scaled")
p_maxprecip_female_rsh <- plot(ce_maxprecip_female_rsh, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_female_rsh <- min(modern_female_r_sittinght$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_female_rsh <- max(modern_female_r_sittinght$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_female_rsh <- p_maxprecip_female_rsh +
  geom_jitter(
    data = modern_female_r_sittinght,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxprecip_min_female_rsh, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_female_rsh, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_female_rsh, y = Inf, label = paste("Min =", round(maxprecip_min_female_rsh, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_female_rsh, y = Inf, label = paste("Max =", round(maxprecip_max_female_rsh, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Relative Sitting Height (Z-score)"
  )
print(p_maxprecip_updated_female_rsh)
```

#### Check the extereme cases
```{r}
modern_female_r_sittinght %>%
  filter(mintemp_scaled > 1.5)
modern_female_r_sittinght %>%
  filter(mintemp_scaled < - 2)
modern_female_r_sittinght %>%
  filter(maxtemp_scaled > 1)
modern_female_r_sittinght %>%
  filter(maxtemp_scaled < - 3)
modern_female_r_sittinght %>%
  filter(minprecip_scaled > 3)
modern_female_r_sittinght %>%
  filter(minprecip_scaled < 0)
modern_female_r_sittinght%>%
  filter(maxprecip_scaled > 3)
modern_female_r_sittinght %>%
  filter(maxprecip_scaled < -1)
```


# Female relative body breadth
```{r}
# Now proceed with scaling spatial and climate predictors, and use the cleaned column for Relative Body Breadth 
modern_female_rbb <- female_data %>%
   filter(!is.na(RelativeBodyBreadth)) %>%
 mutate(
    RelativeBodyBreadth = as.numeric(RelativeBodyBreadth),
    longitude_scaled     = as.numeric(scale(Longitude)[,1]),
    latitude_scaled      = as.numeric(scale(Latitude)[,1]),
    mintemp_scaled       = as.numeric(scale(Mintemp)[,1]),
    maxtemp_scaled       = as.numeric(scale(Maxtemp)[,1]),
    minprecip_scaled     = as.numeric(scale(Minprecip)[,1]),
    maxprecip_scaled     = as.numeric(scale(Maxprecip)[,1]),
       altitude_scaled  = as.numeric(scale(Altitude)[,1]),
    RelativeBodyBreadth_z = as.numeric(scale(RelativeBodyBreadth)[,1])
  )
mean(modern_female_rbb$RelativeBodyBreadth)
sd(modern_female_rbb$RelativeBodyBreadth)
```


```{r}
female_relativebodybreadth_formula_scaled <- bf(
  RelativeBodyBreadth_z ~ t2(longitude_scaled, latitude_scaled) + Time + Urbanism +
    mintemp_scaled + maxtemp_scaled + minprecip_scaled + maxprecip_scaled + 
    altitude_scaled + (1 + Time | Langsubgroup)
)

fit_modern_female_relativebodybreadth_scaled <- brm(
  formula = female_relativebodybreadth_formula_scaled,
  data = modern_female_rbb,
  family = student(),
  prior = c(
    prior(normal(0, 1), class = Intercept),
    prior(normal(0, 1), class = b),
    prior(cauchy(0, 1), class = sigma),
    prior(cauchy(0, 1), class = sd, group = "Langsubgroup"),
    prior(gamma(2, 0.2), class = nu)
  ),
  iter = 4000, warmup = 1000, chains = 4, cores = 4,
  control = list(adapt_delta = 0.99),
  save_pars = save_pars(all = TRUE)
)

summary(fit_modern_female_relativebodybreadth_scaled)
```

## Extract posterior draws
```{r,warning=FALSE}
# Extract posterior draws
post_draws_female_rbb_z <- as_draws_df(fit_modern_female_relativebodybreadth_scaled)

# Extract fixed effects (parameters starting with "b_")
fixef_female_rbb_z <- post_draws_female_rbb_z[, grepl("^b_", colnames(post_draws_female_rbb_z))]

# Remove intercept
fixef_female_rbb_no_int <- fixef_female_rbb_z[, !grepl("Intercept", colnames(fixef_female_rbb_z))]

# Extract random effects
raneff_female_rbb_z <- post_draws_female_rbb_z[, grepl("^r_Langsubgroup", colnames(post_draws_female_rbb_z))]

```

## Plot posterior distributions 
```{r}
# 1) Compute means
fixed_female_rbb_z <- colnames(fixef_female_rbb_no_int)
means_female_rbb_z <- apply(fixef_female_rbb_no_int, 2, mean)
means_female_rbb_df_z <- data.frame(
  parameter = fixed_female_rbb_z,
  mean      = means_female_rbb_z,
  stringsAsFactors = FALSE
)

# 2) Clean column names in both matrix and means dataframe
colnames(fixef_female_rbb_no_int)     <- clean_labels(colnames(fixef_female_rbb_no_int))
means_female_rbb_df_z$parameter       <- clean_labels(means_female_rbb_df_z$parameter)

# 3) Plot
p_fixed_female_rbb_z <- mcmc_areas_ridges(
  fixef_female_rbb_no_int,
  regex_pars = ".*",
  prob       = 0.95
) +
  labs(
    title = "Female Relative Body Breadth",
    x     = "Estimate",
    y     = "Coefficient"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title   = element_text(color = "darkblue", size = 12, face = "bold"),
    axis.title.x = element_text(color = "black", size = 12),
    axis.text    = element_text(color = "black", size = 12)
  ) +
  geom_vline(
    xintercept = 0,
    linetype   = "dashed",
    color      = "red",
    linewidth  = 0.8
  ) +
  geom_point(
    data     = means_female_rbb_df_z,
    aes(x = mean, y = parameter),
    shape    = 124,
    size     = 3,
    color    = "blue",
    position = position_nudge(y = 0.5)
  )

# Print the plot
p_fixed_female_rbb_z

```

### Random density plot
```{r}
# 3) Identify intercept vs. slope columns
random_intercept_female_rbb_z <- grep(
  "Intercept", 
  colnames(raneff_female_rbb_z), 
  value = TRUE
)
random_slope_female_rbb_z <- grep("TimeLate", colnames(raneff_female_rbb_z), value = TRUE)
random_slope_female_rbb_z <- random_slope_female_rbb_z[!grepl("Austronesian", random_slope_female_rbb_z)]

# 5a) Plot random intercepts
p_random_intercepts_female_rbb_z <- mcmc_areas(
  raneff_female_rbb_z,
  pars = random_intercept_female_rbb_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Intercept (Female Relative Body Breadth Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 5b) Plot random slopes for Time
p_random_slopes_female_rbb_z <- mcmc_areas(
  raneff_female_rbb_z,
  pars = random_slope_female_rbb_z,
  prob = 0.95
) +
  scale_y_discrete(labels = clean_random_labels) +
  labs(x = "Random Slope for Time (Female Relative Body Breadth Z)") +
  theme_minimal(base_size = 12) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red", linewidth = 0.2)

# 6) Display them side‐by‐side
(p_random_intercepts_female_rbb_z | p_random_slopes_female_rbb_z) +
  plot_layout(ncol = 2) &
  theme(plot.margin = margin(5, 5, 5, 5))
```


## Full Prediction for Female Relative Body Breadth (Early Rural)
```{r}
# 1. Create a full geographic grid using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full female relative body breadth model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban")),
      # Scale predictors using female-specific parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female relative body breadth using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_relativebodybreadth_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_relativebodybreadth_z,
  file = here("output", "final_female_relativebodybreadth_predictions_20chunks_z_with_coordinates_early_rural.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female relative body breadth complete and saved.\n")
```



## Full Prediction for Female Relative Body Breadth (Late Urban)
```{r}
# 1. Create a full geographic grid using Longitude & Latitude
grid_geo <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# 2. Split the grid into 20 equal chunks
num_chunks <- 20
grid_segments <- split(grid_geo, cut(seq_len(nrow(grid_geo)), breaks = num_chunks, labels = FALSE))

# 3. Loop over chunks and predict using the full female relative body breadth model
predictions_list <- list()

for (i in seq_along(grid_segments)) {
  cat("Processing chunk", i, "of", length(grid_segments), "\n")
  
  grid_chunk <- grid_segments[[i]]
  
  # Extract environmental raster values
  grid_chunk <- grid_chunk %>%
    mutate(
      Mintemp      = extract(Mintemp_raster, cbind(Longitude, Latitude)),
      Maxtemp      = extract(Maxtemp_raster, cbind(Longitude, Latitude)),
      Minprecip    = extract(Minprecip_raster, cbind(Longitude, Latitude)),
      Maxprecip    = extract(Maxprecip_raster, cbind(Longitude, Latitude)),
      Altitude_abs = extract(Altitude_raster, cbind(Longitude, Latitude))
    ) %>%
    mutate(
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban")),
      # Scale predictors using female-specific parameters
      mintemp_scaled   = (Mintemp      - female_mintemp_center)   / female_mintemp_scale,
      maxtemp_scaled   = (Maxtemp      - female_maxtemp_center)   / female_maxtemp_scale,
      minprecip_scaled = (Minprecip    - female_minprecip_center) / female_minprecip_scale,
      maxprecip_scaled = (Maxprecip    - female_maxprecip_center) / female_maxprecip_scale,
      altitude_scaled  = (Altitude_abs - female_altitude_center)  / female_altitude_scale,
      longitude_scaled = (Longitude    - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude     - female_latitude_center)  / female_latitude_scale
    )
  
  # Predict z-scored female relative body breadth using the full model (fixed effects only)
  seg_predictions <- predict(
    fit_modern_female_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- seg_predictions[, "Estimate"]
  predictions_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# 4. Combine predictions from all chunks and save to CSV
final_predictions_female_relativebodybreadth_z <- do.call(rbind, predictions_list)

write.csv(
  final_predictions_female_relativebodybreadth_z,
  file = here("output", "final_female_relativebodybreadth_predictions_20chunks_z_with_coordinates_late_urban.csv"),
  row.names = FALSE
)

cat("Full grid prediction for female relative body breadth complete and saved.\n")
```


### Coordinate-only Prediction for Female Relative Body Breadth (Early Rural)
```{r}
# Create geographic grid (if not already created)
grid_female_relativebodybreadth_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_relativebodybreadth_coordonly, 
                            cut(seq_len(nrow(grid_female_relativebodybreadth_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using female-specific parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Early", levels = c("Early", "Late")),
      Urbanism = factor("Rural", levels = c("Rural", "Urban"))
    )
  
  # Predict using the full female relative body breadth model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_relativebodybreadth_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_relativebodybreadth_coordonly_z,
          file = here("output", "female_relativebodybreadth_pred_coordonly_chunks_z_early_rural.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female relative body breadth complete!\n")
```



### Coordinate-only Prediction for Female Relative Body Breadth (Late Urban)
```{r}
# Create geographic grid (if not already created)
grid_female_relativebodybreadth_coordonly <- expand.grid(
  Longitude = seq(70, 140, length.out = 400),
  Latitude  = seq(10, 60, length.out = 400)
)

# Split the grid into 20 equal chunks
num_chunks <- 20
grid_female_chunks <- split(grid_female_relativebodybreadth_coordonly, 
                            cut(seq_len(nrow(grid_female_relativebodybreadth_coordonly)), 
                                breaks = num_chunks, labels = FALSE))

# Initialize list to store predictions
predictions_coordonly_list <- list()

for (i in seq_along(grid_female_chunks)) {
  cat("Processing coordinate-only chunk", i, "of", length(grid_female_chunks), "\n")
  
  grid_chunk <- grid_female_chunks[[i]] %>%
    mutate(
      # Scale spatial coordinates using female-specific parameters
      longitude_scaled = (Longitude - female_longitude_center) / female_longitude_scale,
      latitude_scaled  = (Latitude - female_latitude_center) / female_latitude_scale,
      
      # Set environmental predictors to 0 (their scaled mean)
      mintemp_scaled    = 0,
      maxtemp_scaled    = 0,
      minprecip_scaled  = 0,
      maxprecip_scaled  = 0,
      altitude_scaled   = 0,
      
      # Set categorical controls
      Time     = factor("Late", levels = c("Early", "Late")),
      Urbanism = factor("Urban", levels = c("Rural", "Urban"))
    )
  
  # Predict using the full female relative body breadth model (fixed effects only)
  chunk_pred <- predict(
    fit_modern_female_relativebodybreadth_scaled,
    newdata = grid_chunk,
    re_formula = ~0
  )
  
  grid_chunk$RelativeBodyBreadth_pred_z <- chunk_pred[, "Estimate"]
  predictions_coordonly_list[[i]] <- grid_chunk
  
  rm(grid_chunk)
  gc()
}

# Combine predictions from all chunks and save to CSV
df_female_relativebodybreadth_coordonly_z <- do.call(rbind, predictions_coordonly_list)

write.csv(df_female_relativebodybreadth_coordonly_z,
          file = here("output", "female_relativebodybreadth_pred_coordonly_chunks_z_late_urban.csv"),
          row.names = FALSE)

cat("Coordinate-only prediction for female relative body breadth complete!\n")
```


###------ Early Rural-------
### Visualization for Full Prediction of Female Relative Body Breadth (Early Rural)
```{r}
# 1. Read the predicted female relative body breadth (z-scores)
extended_grid_female_relativebodybreadth <- read.csv(here("output", "final_female_relativebodybreadth_predictions_20chunks_z_with_coordinates_early_rural.csv"))
head(extended_grid_female_relativebodybreadth)

# 2. (Optional) Convert z-scores back to raw values using the original mean and SD
relativebodybreadth_mean <- mean(modern_female_rbb$RelativeBodyBreadth, na.rm = TRUE)
relativebodybreadth_sd   <- sd(modern_female_rbb$RelativeBodyBreadth, na.rm = TRUE)

extended_grid_female_relativebodybreadth <- extended_grid_female_relativebodybreadth %>%
  mutate(RelativeBodyBreadth_raw = RelativeBodyBreadth_pred_z * relativebodybreadth_sd + relativebodybreadth_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_relativebodybreadth <- extended_grid_female_relativebodybreadth %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RelativeBodyBreadth_z   = mean(RelativeBodyBreadth_pred_z, na.rm = TRUE),
    RelativeBodyBreadth_raw = mean(RelativeBodyBreadth_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_relativebodybreadth <- rasterFromXYZ(spatial_trends_female_relativebodybreadth[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")])
rast_z_female_relativebodybreadth <- mask(rast_z_female_relativebodybreadth, basemap_sp_wgs84)
crs(rast_z_female_relativebodybreadth) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_relativebodybreadth <- as.data.frame(rasterToPoints(rast_z_female_relativebodybreadth), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_relativebodybreadth) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# 6. Plot the spatial trends of predicted female relative body breadth (z-scored)
p_spatial_trends_z_female_relativebodybreadth_early_rural <- ggplot(spatial_trends_z_female_relativebodybreadth, 
                                                        aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,             # female-specific color palette
    limits = z_limits,  # e.g., c(-2, 2)
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_female_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Relative Body Breadth (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_female_relativebodybreadth_early_rural)
```

### Visualization for Coordinate-only Prediction of Female Relative Body Breadth （Early Rural)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_relativebodybreadth_coordonly_z <- read.csv(here("output", "female_relativebodybreadth_pred_coordonly_chunks_z_early_rural.csv"))
head(df_female_relativebodybreadth_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_relativebodybreadth_coordonly_z)[colnames(df_female_relativebodybreadth_coordonly_z) == "RelativeBodyBreadth_pred_z"] <- "RelativeBodyBreadth_z"

# Convert to raster using Longitude, Latitude, and RelativeBodyBreadth_z
rast_female_relativebodybreadth_coordonly_z <- rasterFromXYZ(
  df_female_relativebodybreadth_coordonly_z[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")]
)

# Mask the raster with the basemap shapefile
rast_female_relativebodybreadth_coordonly_z <- mask(rast_female_relativebodybreadth_coordonly_z, basemap_sp_wgs84)
crs(rast_female_relativebodybreadth_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for plotting
df_female_relativebodybreadth_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_relativebodybreadth_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_relativebodybreadth_coordonly_z_plot) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# Plot the residual spatial pattern in predicted female relative body breadth (z-scored)
p_female_relativebodybreadth_coordonly_z_early_rural <- ggplot(df_female_relativebodybreadth_coordonly_z_plot,
                                                   aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,           # female-specific color palette
    limits = z_limits,  # e.g., c(-2, 2)
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_female_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Relative Body Breadth (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )

print(p_female_relativebodybreadth_coordonly_z_early_rural)
```

### Comparing "Full model" vs "Coordinate-only" prediction (Early Rural)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_RelativeBodyBreadth_z <- extended_grid_female_relativebodybreadth %>%
 dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_full = RelativeBodyBreadth_pred_z
) %>%
  inner_join(
    df_female_relativebodybreadth_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_coordonly = RelativeBodyBreadth_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RelativeBodyBreadth_z_full - RelativeBodyBreadth_z_coordonly
  )

comparison_female_RelativeBodyBreadth_z <- comparison_female_RelativeBodyBreadth_z  %>%
  filter(!is.na(RelativeBodyBreadth_z_full) & !is.na(RelativeBodyBreadth_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_rbb <- rasterFromXYZ(comparison_female_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_full")])
r_coord_female_rbb  <- rasterFromXYZ(comparison_female_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_coordonly")])
r_env_female_rbb    <- rasterFromXYZ(comparison_female_RelativeBodyBreadth_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_rbb <- stack(r_full_female_rbb, r_coord_female_rbb, r_env_female_rbb)
names(r_stack_female_rbb) <- c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect")
r_stack_masked_female_rbb <- mask(r_stack_female_rbb, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_rbb <- as.data.frame(rasterToPoints(r_stack_masked_female_rbb)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_RelativeBodyBreadth_z_masked <- df_masked_female_rbb %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_relativeBodyBreadth_long_z_masked <- comparison_female_RelativeBodyBreadth_z_masked  %>%
  pivot_longer(c(RelativeBodyBreadth_z_full, RelativeBodyBreadth_z_coordonly, Env_effect),
               names_to="Model", values_to="RelativeBodyBreadth_z") %>%
  mutate(Model = factor(Model,
    levels = c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_female_rbb_early_rural <- ggplot(comparison_female_relativeBodyBreadth_long_z_masked , 
                     aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
    scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_female_rbb_early_rural
```

###------ Late Urban-------
### Visualization for Full Prediction of Female Relative Body Breadth (Late Urban)
```{r}
# 1. Read the predicted female relative body breadth (z-scores)
extended_grid_female_relativebodybreadth <- read.csv(here("output", "final_female_relativebodybreadth_predictions_20chunks_z_with_coordinates_late_urban.csv"))
head(extended_grid_female_relativebodybreadth)

# 2. (Optional) Convert z-scores back to raw values using the original mean and SD
relativebodybreadth_mean <- mean(modern_female_rbb$RelativeBodyBreadth, na.rm = TRUE)
relativebodybreadth_sd   <- sd(modern_female_rbb$RelativeBodyBreadth, na.rm = TRUE)

extended_grid_female_relativebodybreadth <- extended_grid_female_relativebodybreadth %>%
  mutate(RelativeBodyBreadth_raw = RelativeBodyBreadth_pred_z * relativebodybreadth_sd + relativebodybreadth_mean)

# 3. Average predictions across grid cells for spatial trends
spatial_trends_female_relativebodybreadth <- extended_grid_female_relativebodybreadth %>%
  group_by(Longitude, Latitude) %>%
  summarise(
    RelativeBodyBreadth_z   = mean(RelativeBodyBreadth_pred_z, na.rm = TRUE),
    RelativeBodyBreadth_raw = mean(RelativeBodyBreadth_raw, na.rm = TRUE)
  ) %>%
  ungroup()

# 4. Create a raster from the z-scored predictions and mask with the basemap
rast_z_female_relativebodybreadth <- rasterFromXYZ(spatial_trends_female_relativebodybreadth[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")])
rast_z_female_relativebodybreadth <- mask(rast_z_female_relativebodybreadth, basemap_sp_wgs84)
crs(rast_z_female_relativebodybreadth) <- CRS("+proj=longlat +datum=WGS84")

# 5. Convert the raster to a data frame for plotting
spatial_trends_z_female_relativebodybreadth <- as.data.frame(rasterToPoints(rast_z_female_relativebodybreadth), stringsAsFactors = FALSE)
colnames(spatial_trends_z_female_relativebodybreadth) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# 6. Plot the spatial trends of predicted female relative body breadth (z-scored)
p_spatial_trends_z_female_relativebodybreadth_late_urban <- ggplot(spatial_trends_z_female_relativebodybreadth, 
                                                        aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,             # female-specific color palette
    limits = z_limits,  # e.g., c(-2, 2)
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_female_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Spatial Trends of Predicted Female Relative Body Breadth (Z-Scored)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin     = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title      = element_text(size = 12, face = "bold"),
    axis.title      = element_text(size = 12),
    axis.text       = element_text(size = 10),
    legend.title    = element_text(size = 10),
    legend.text     = element_text(size = 10)
  )

print(p_spatial_trends_z_female_relativebodybreadth_late_urban)
```

### Visualization for Coordinate-only Prediction of Female Relative Body Breadth （Late Urban)
```{r}
# Read the coordinate-only prediction CSV (z-scores)
df_female_relativebodybreadth_coordonly_z <- read.csv(here("output", "female_relativebodybreadth_pred_coordonly_chunks_z_late_urban.csv"))
head(df_female_relativebodybreadth_coordonly_z)  # Optional check

# Rename predicted column for clarity if needed
colnames(df_female_relativebodybreadth_coordonly_z)[colnames(df_female_relativebodybreadth_coordonly_z) == "RelativeBodyBreadth_pred_z"] <- "RelativeBodyBreadth_z"

# Convert to raster using Longitude, Latitude, and RelativeBodyBreadth_z
rast_female_relativebodybreadth_coordonly_z <- rasterFromXYZ(
  df_female_relativebodybreadth_coordonly_z[, c("Longitude", "Latitude", "RelativeBodyBreadth_z")]
)

# Mask the raster with the basemap shapefile
rast_female_relativebodybreadth_coordonly_z <- mask(rast_female_relativebodybreadth_coordonly_z, basemap_sp_wgs84)
crs(rast_female_relativebodybreadth_coordonly_z) <- CRS("+proj=longlat +datum=WGS84")

# Convert the masked raster to a data frame for plotting
df_female_relativebodybreadth_coordonly_z_plot <- as.data.frame(
  rasterToPoints(rast_female_relativebodybreadth_coordonly_z),
  stringsAsFactors = FALSE
)
colnames(df_female_relativebodybreadth_coordonly_z_plot) <- c("Longitude", "Latitude", "RelativeBodyBreadth_z")

# Plot the residual spatial pattern in predicted female relative body breadth (z-scored)
p_female_relativebodybreadth_coordonly_z_late_urban <- ggplot(df_female_relativebodybreadth_coordonly_z_plot,
                                                   aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84),
          inherit.aes = FALSE,
          color = "darkgray",
          linewidth = 1) +
  scale_fill_gradientn(
    colors = female_colors_z,           # female-specific color palette
    limits = z_limits,  # e.g., c(-2, 2)
    name = "Relative Body Breadth (z-score)",
    na.value = "transparent"
  ) +
  # Add original sites as points
  geom_point(data = modern_female_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.8, 
             shape = 24, 
             fill = "red", 
             color = "white", 
             stroke = 0.5,
             inherit.aes = FALSE) +
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    title = "Residual Spatial Pattern in Predicted Female Relative Body Breadth (Z-Score)",
    subtitle = "Predicted with Spatial Coordinates Only (Env Held Constant)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    legend.position = "right",
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 10)
  )

print(p_female_relativebodybreadth_coordonly_z_late_urban)
```
### Comparing "Full model" vs "Coordinate-only" prediction (Late Urban)
```{r}
# Merge full prediction and coordinate-only prediction
comparison_female_RelativeBodyBreadth_z <- extended_grid_female_relativebodybreadth %>%
 dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_full = RelativeBodyBreadth_pred_z
) %>%
  inner_join(
    df_female_relativebodybreadth_coordonly_z %>%
      dplyr::select(Longitude, Latitude, RelativeBodyBreadth_z_coordonly = RelativeBodyBreadth_z),
    by = c("Longitude", "Latitude")
  ) %>%
  mutate(
    Env_effect = RelativeBodyBreadth_z_full - RelativeBodyBreadth_z_coordonly
  )

comparison_female_RelativeBodyBreadth_z <- comparison_female_RelativeBodyBreadth_z  %>%
  filter(!is.na(RelativeBodyBreadth_z_full) & !is.na(RelativeBodyBreadth_z_coordonly) & !is.na(Env_effect))

# 1. Build individual rasters
r_full_female_rbb <- rasterFromXYZ(comparison_female_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_full")])
r_coord_female_rbb  <- rasterFromXYZ(comparison_female_RelativeBodyBreadth_z[, c("Longitude","Latitude","RelativeBodyBreadth_z_coordonly")])
r_env_female_rbb    <- rasterFromXYZ(comparison_female_RelativeBodyBreadth_z[, c("Longitude","Latitude","Env_effect")])

# 2. Stack and mask in one go
r_stack_female_rbb <- stack(r_full_female_rbb, r_coord_female_rbb, r_env_female_rbb)
names(r_stack_female_rbb) <- c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect")
r_stack_masked_female_rbb <- mask(r_stack_female_rbb, basemap_sp_wgs84)

# 3. Back to a tibble
df_masked_female_rbb <- as.data.frame(rasterToPoints(r_stack_masked_female_rbb)) %>%
  rename(Longitude = x, Latitude = y)

# 4. Classify strong vs. weak effects
comparison_female_RelativeBodyBreadth_z_masked <- df_masked_female_rbb %>%
  mutate(
    Env_effect_category = if_else(abs(Env_effect) >= 0.3, "Strong", "Weak")
  )

# reshape for the three panels
comparison_female_relativeBodyBreadth_long_z_masked <- comparison_female_RelativeBodyBreadth_z_masked  %>%
  pivot_longer(c(RelativeBodyBreadth_z_full, RelativeBodyBreadth_z_coordonly, Env_effect),
               names_to="Model", values_to="RelativeBodyBreadth_z") %>%
  mutate(Model = factor(Model,
    levels = c("RelativeBodyBreadth_z_full","RelativeBodyBreadth_z_coordonly","Env_effect"),
    labels = c(
      "A) Full Model (Climate + Space)",
      "B) Coordinate-only Model (Space Only)",
      "C) Environmental Effect (Full–Coordonly)"
    )
  ))

p_models_z_female_rbb_late_urban <- ggplot(comparison_female_relativeBodyBreadth_long_z_masked , 
                     aes(x = Longitude, y = Latitude, fill = RelativeBodyBreadth_z)) +
  geom_raster() +
  geom_sf(data = st_boundary(basemap_wgs84), inherit.aes = FALSE,
          color = "grey", linewidth = 0.3) +
  facet_wrap(~Model, ncol = 3) +
  scale_fill_gradientn(
    colors = female_colors_z,
    limits = z_limits,
    name = "z-score",
    na.value = "transparent"
  ) +
   # Add original sites as points
  geom_point(data = modern_female_rbb, 
             mapping = aes(x = Longitude, y = Latitude), 
             size = 0.2, 
             shape = 24, 
             fill = "red", 
             color = "red", 
             stroke = 0.1,
             inherit.aes = FALSE) +
    scale_x_continuous(
    breaks = seq(70, 140, by = 20)
  ) + 
  coord_sf(xlim = c(70, 140), ylim = c(10, 60), expand = FALSE) +
  labs(
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(
    plot.margin = margin(3, 4, 3, 4, unit = "pt"),
    strip.text = element_blank(),
    plot.title = element_text(size = 6, face = "bold"),
    axis.title = element_text(size = 6),
    axis.text = element_text(size = 6),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6)
  )

p_models_z_female_rbb_late_urban
```


### Conditional Effect - separated
#### Conditional Effect for Altitude
```{r, warning=FALSE}
# Extract conditional effect
ce_altitude_female_rbb <- conditional_effects(fit_modern_female_relativebodybreadth_scaled, effects = "altitude_scaled")
p_altitude_female_rbb <- plot(ce_altitude_female_rbb, ask = FALSE)[["altitude_scaled"]]

# Get observed min and max
altitude_min_female_rbb <- min(modern_female_rbb$altitude_scaled, na.rm = TRUE)
altitude_max_female_rbb <- max(modern_female_rbb$altitude_scaled, na.rm = TRUE)

# Create “tick” plot
p_altitude_jitter_ticks_female_rbb <- p_altitude_female_rbb +
  # Highlight high-altitude region
  geom_rect(
    aes(xmin = 1.84, xmax = Inf, ymin = -Inf, ymax = Inf),
    fill = "lightblue", alpha = 0.01, inherit.aes = FALSE
  ) +
  geom_vline(xintercept = 1.84, linetype = "dotted", color = "blue") +
  annotate(
    "text", x = 2, y = max(p_altitude_female_rbb$data$estimate__, na.rm = TRUE),
    label = "High Altitude (>2500m asl)", color = "blue", size = 4, hjust = 0
  ) +

  geom_jitter(
    data       = modern_female_rbb,
   mapping  = aes(x = altitude_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  # Range markers
  geom_vline(xintercept = altitude_min_female_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = altitude_max_female_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = altitude_min_female_rbb, y = Inf, 
           label = paste("Min =", round(altitude_min_female_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = altitude_max_female_rbb, y = Inf, 
           label = paste("Max =", round(altitude_max_female_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +

  # Labels
  labs(
    title = "Conditional Effect of Altitude",
    x     = "Scaled Altitude",
    y     = "Predicted Relative Body Breadth (Z-score)"
  )

print(p_altitude_jitter_ticks_female_rbb)

modern_female_rbb %>%
  filter(altitude_scaled > 1.84)
```

#### Conditional Effect for Minimum Temperature (mintemp_scaled)
```{r, warning=FALSE}
ce_mintemp_female_rbb <- conditional_effects(fit_modern_female_relativebodybreadth_scaled, effects = "mintemp_scaled")
p_mintemp_female_rbb <- plot(ce_mintemp_female_rbb, ask = FALSE)[["mintemp_scaled"]]

# Extract range
temp_min_female_rbb  <- min(modern_female_rbb$mintemp_scaled, na.rm = TRUE)
temp_max_female_rbb <- max(modern_female_rbb$mintemp_scaled, na.rm = TRUE)

p_mintemp_updated_female_rbb <- p_mintemp_female_rbb +
  geom_jitter(
    data     = modern_female_rbb,
    mapping  = aes(x = mintemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1) ,
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = temp_min_female_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = temp_max_female_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = temp_min_female_rbb, y = Inf, label = paste("Min =", round(temp_min_female_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = temp_max_female_rbb, y = Inf, label = paste("Max =", round(temp_max_female_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Mintemp",
    x = "Scaled Mintemp",
    y = "Predicted Relative Body Breadth (Z-score)"
  ) 

print(p_mintemp_updated_female_rbb)
```

#### Conditional Effect for Maximum Temperature (maxtemp_scaled)
```{r}
ce_maxtemp_female_rbb <- conditional_effects(fit_modern_female_relativebodybreadth_scaled, effects = "maxtemp_scaled")
p_maxtemp_female_rbb <- plot(ce_maxtemp_female_rbb, ask = FALSE)[["maxtemp_scaled"]]

maxtemp_min_female_rbb <- min(modern_female_rbb$maxtemp_scaled, na.rm = TRUE)
maxtemp_max_female_rbb <- max(modern_female_rbb$maxtemp_scaled, na.rm = TRUE)

p_maxtemp_updated_female_rbb <- p_maxtemp_female_rbb +
  geom_jitter(
    data = modern_female_rbb,
    mapping = aes(x = maxtemp_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxtemp_min_female_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxtemp_max_female_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxtemp_min_female_rbb, y = Inf, label = paste("Min =", round(maxtemp_min_female_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxtemp_max_female_rbb, y = Inf, label = paste("Max =", round(maxtemp_max_female_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxtemp",
    x     = "Scaled Maxtemp",
    y     = "Predicted Relative Body Breadth (Z-score)"
  ) 

print(p_maxtemp_updated_female_rbb)
```

####Conditional Effect for Minimum Precipitation (minprecip_scaled)
```{r, warning=FALSE}
ce_minprecip_female_rbb <- conditional_effects(fit_modern_female_relativebodybreadth_scaled, effects = "minprecip_scaled")
p_minprecip_female_rbb <- plot(ce_minprecip_female_rbb, ask = FALSE)[["minprecip_scaled"]]

minprecip_min_female_rbb <- min(modern_female_rbb$minprecip_scaled, na.rm = TRUE)
minprecip_max_female_rbb <- max(modern_female_rbb$minprecip_scaled, na.rm = TRUE)

p_minprecip_updated_female_rbb <- p_minprecip_female_rbb +
  geom_jitter(
    data = modern_female_rbb,
    mapping = aes(x = minprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = minprecip_min_female_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = minprecip_max_female_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = minprecip_min_female_rbb, y = Inf, label = paste("Min =", round(minprecip_min_female_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = minprecip_max_female_rbb, y = Inf, label = paste("Max =", round(minprecip_max_female_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Minprecip",
    x     = "Scaled Minprecip",
    y     = "Predicted Relative Body Breadth (Z-score)"
  )
print(p_minprecip_updated_female_rbb)
```

#### Conditional Effect for Maximum Precipitation (maxprecip_scaled)
```{r, warning=FALSE}
ce_maxprecip_female_rbb <- conditional_effects(fit_modern_female_relativebodybreadth_scaled, effects = "maxprecip_scaled")
p_maxprecip_female_rbb <- plot(ce_maxprecip_female_rbb, ask = FALSE)[["maxprecip_scaled"]]

maxprecip_min_female_rbb <- min(modern_female_rbb$maxprecip_scaled, na.rm = TRUE)
maxprecip_max_female_rbb <- max(modern_female_rbb$maxprecip_scaled, na.rm = TRUE)

p_maxprecip_updated_female_rbb <- p_maxprecip_female_rbb +
  geom_jitter(
    data = modern_female_rbb,
    mapping = aes(x = maxprecip_scaled, y = -Inf),      # anchor at bottom
    inherit.aes = FALSE,
    shape    = "|",                                     # vertical bar “|”
    size     = 3,                                       # thickness of your tick
    alpha    = 0.5,
    color    = "blue",
    position = position_jitter(width = 0.01, height = 0.1),
    clip     = "off"
  ) +
  coord_cartesian(clip = "off") +                # allow y = -Inf bars to show
  geom_vline(xintercept = maxprecip_min_female_rbb, linetype = "dashed", color = "salmon") +
  geom_vline(xintercept = maxprecip_max_female_rbb, linetype = "dashed", color = "salmon") +
  annotate("text", x = maxprecip_min_female_rbb, y = Inf, label = paste("Min =", round(maxprecip_min_female_rbb, 2)),
           hjust = 0, vjust = 2, color = "red", size = 4) +
  annotate("text", x = maxprecip_max_female_rbb, y = Inf, label = paste("Max =", round(maxprecip_max_female_rbb, 2)),
           hjust = 1, vjust = 2, color = "red", size = 4) +
  labs(
    title = "Conditional Effect of Maxprecip",
    x = "Scaled Maxprecip",
    y = "Predicted Relative Body Breadth (Z-score)"
  )
print(p_maxprecip_updated_female_rbb)
```

#### Check the extereme cases
```{r}
modern_female_rbb %>%
  filter(mintemp_scaled > 1.5)
modern_female_rbb %>%
  filter(mintemp_scaled < - 2)
modern_female_rbb %>%
  filter(maxtemp_scaled > 1)
modern_female_rbb %>%
  filter(maxtemp_scaled < - 3)
modern_female_rbb %>%
  filter(minprecip_scaled > 3)
modern_female_rbb %>%
  filter(minprecip_scaled < 0)
modern_female_rbb%>%
  filter(maxprecip_scaled > 3)
modern_female_rbb %>%
  filter(maxprecip_scaled < -1)
```



# Panel things
## Fixed Effects
```{r}
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)

tag_style <- theme(
  plot.tag.position = c(0.02, 0.98), 
  plot.tag          = element_text(size = 10, face = "bold", hjust = 0, vjust = 1)
)

# 2) Strip out titles and add tags for each of the 8 panels:

# Row A: Stature
p_A_I  <- p_fixed_male_stature_z   + labs(title = NULL, tag = "A I")  + blank_x + tag_style
p_A_II <- p_fixed_female_stature_z + labs(title = NULL, tag = "A II") + blank_x + tag_style +
  scale_y_discrete(labels = NULL)

# Row B: Body Mass
p_B_I  <- p_fixed_male_bodymass_z   + labs(title = NULL, tag = "B I")  + blank_x + tag_style
p_B_II <- p_fixed_female_bodymass_z + labs(title = NULL, tag = "B II") + blank_x + tag_style +
  scale_y_discrete(labels = NULL)

# Row C: Relative Sitting Height
p_C_I  <- p_fixed_male_r_sittinght_z   + labs(title = NULL, tag = "C I")  + blank_x + tag_style
p_C_II <- p_fixed_female_r_sittinght_z + labs(title = NULL, tag = "C II") + blank_x + tag_style +
  scale_y_discrete(labels = NULL)

# Row D: Relative Body Breadth
p_D_I  <- p_fixed_male_rbb_z   + labs(title = NULL, tag = "D I")  + blank_x + tag_style
p_D_II <- p_fixed_female_rbb_z + labs(title = NULL, tag = "D II") + blank_x + tag_style +
  scale_y_discrete(labels = NULL)

# 3) Combine into 4 rows × 2 columns
combined_fixed_effects <- (
   (p_A_I  | p_A_II) /
   (p_B_I  | p_B_II) /
   (p_C_I  | p_C_II) /
   (p_D_I  | p_D_II)
) + plot_layout(ncol = 2, widths = c(1, 1))+
  plot_annotation(
    title    = "Posterior Distributions of Fixed Effects by Sex and Trait",
    subtitle = paste(
      "Rows A–D: A = Stature; B = Body mass; C = Relative sitting height; D = Relative body breadth.\nColumns I vs II: I = Male; II = Female."
    )
  ) &
  theme_minimal(base_size = 10) &
  theme(
    plot.title    = element_text(size = 12, face = "bold"),
    plot.subtitle = element_text(size = 12),
    panel.spacing = unit(1, "lines"),
    plot.tag       = element_text(size = 12, face = "bold"),  # override
    plot.tag.position = c(0.02, 0.98),    
    axis.title.y   = element_blank(),
    axis.title.x   = element_blank(),
    axis.text.y    = element_text(size = 12,colour = "black"),
    axis.text.x    = element_text(size = 12),
    plot.margin    = margin(1, 1, 1, 1)  # nudge in from edges
  )

# 4) Render
print(combined_fixed_effects)
```

```{r}
# 1) Compute a common x‐axis range across all fixed‐effect draws
all_fixed_values <- c(
  as.matrix(fixef_male_stature_no_int),
  as.matrix(fixef_female_stature_no_int),
  as.matrix(fixef_male_bodymass_no_int),
  as.matrix(fixef_female_bodymass_no_int),
  as.matrix(fixef_male_r_sittinght_no_int),
  as.matrix(fixef_female_r_sittinght_no_int),
  as.matrix(fixef_male_rbb_no_int),
  as.matrix(fixef_female_rbb_no_int)
)
global_limits <- range(all_fixed_values, na.rm = TRUE)
pad <- diff(global_limits) * 0.05
xlims <- global_limits + c(-pad, pad)
common_scale <- scale_x_continuous(limits = xlims)

# 2) Tag styling (top‐left of each panel)
tag_style <- theme(
  plot.tag.position = c(0.02, 0.98),
  plot.tag          = element_text(size = 12, face = "bold", hjust = 0, vjust = 1)
)

# 3) Blank out all x‐axis elements
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)

# 4) Prepare each plot: remove its title, add tag, apply common scale & blank_x
pA_I  <- p_fixed_male_stature_z   + labs(tag = "A I", title = NULL) + common_scale + blank_x + tag_style
pA_II <- p_fixed_female_stature_z + labs(tag = "A II", title = NULL) + common_scale + blank_x + tag_style

pB_I  <- p_fixed_male_bodymass_z   + labs(tag = "B I", title = NULL) + common_scale + blank_x + tag_style
pB_II <- p_fixed_female_bodymass_z + labs(tag = "B II", title = NULL) + common_scale + blank_x + tag_style

pC_I  <- p_fixed_male_r_sittinght_z   + labs(tag = "C I", title = NULL) + common_scale + blank_x + tag_style
pC_II <- p_fixed_female_r_sittinght_z + labs(tag = "C II", title = NULL) + common_scale + blank_x + tag_style

pD_I  <- p_fixed_male_rbb_z   + labs(tag = "D I", title = NULL) + common_scale + blank_x + tag_style
pD_II <- p_fixed_female_rbb_z + labs(tag = "D II", title = NULL) + common_scale + blank_x + tag_style

# 5) Combine in 2 columns × 4 rows
combined_fixed_effects <- (
     pA_I  | pA_II
  ) / (
     pB_I  | pB_II
  ) / (
     pC_I  | pC_II
  ) / (
     pD_I  | pD_II
  ) +
  plot_layout(ncol     = 1,
              heights  = rep(1,4)) +
  plot_annotation(
    title    = "Posterior Distributions of Fixed Effects",
    subtitle = paste(
      "Rows (A–D): A = Stature; B = Body mass; C = Relative sitting height; D = Relative body breadth.",
      "Columns (I, II): I = Male; II = Female."
    )
  ) &
  theme_minimal(base_size = 11) &
  theme(
    plot.title    = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 10),
    axis.title.x  = element_blank(),   # ensure no x‑axis title
    axis.text.x   = element_blank(),   # no x‑axis labels
    axis.ticks.x  = element_blank()    # no x‑axis ticks
  )

# 6) Render
print(combined_fixed_effects)

```


```{r}
# 1) Compute common x‐axis limits (unchanged)
all_fixed_values <- c(
  as.matrix(fixef_male_stature_no_int),
  as.matrix(fixef_female_stature_no_int),
  as.matrix(fixef_male_bodymass_no_int),
  as.matrix(fixef_female_bodymass_no_int),
  as.matrix(fixef_male_r_sittinght_no_int),
  as.matrix(fixef_female_r_sittinght_no_int),
  as.matrix(fixef_male_rbb_no_int),
  as.matrix(fixef_female_rbb_no_int)
)
global_limits <- range(all_fixed_values, na.rm = TRUE)
pad <- diff(global_limits) * 0.05
xlims <- global_limits + c(-pad, pad)
common_scale <- scale_x_continuous(limits = xlims)

# 2) Blank out x‐axis (we’ll keep this)
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)

# 3) Build each panel *without* tags or titles.
#    Left‐column panels get a y‐label; right ones get none.
pA_I  <- p_fixed_male_stature_z   +
         labs(x = NULL, title = NULL, y = "Stature")      +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pA_II <- p_fixed_female_stature_z +
         labs(x = NULL, title = NULL, y = NULL)          +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pB_I  <- p_fixed_male_bodymass_z   +
         labs(x = NULL, title = NULL, y = "Body mass")     +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pB_II <- p_fixed_female_bodymass_z +
         labs(x = NULL, title = NULL, y = NULL)           +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pC_I  <- p_fixed_male_r_sittinght_z   +
         labs(x = NULL, title = NULL, y = "Rel. sitting height") +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pC_II <- p_fixed_female_r_sittinght_z +
         labs(x = NULL, title = NULL, y = NULL)                +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pD_I  <- p_fixed_male_rbb_z   +
         labs(x = NULL, title = NULL, y = "Rel. body breadth") +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

pD_II <- p_fixed_female_rbb_z +
         labs(x = NULL, title = NULL, y = NULL)             +
         common_scale + blank_x + theme_minimal(base_size = 11)+
  theme(
    axis.text.y = element_text(face = "bold")
  )

# 4) Create a tiny “symbol” row for ♂ and ♀
symbol_male   <- ggplot() +
  annotate("text", x = 0.5, y = 0.45, label = "\u2642", size = 8,
    fontface = "bold") +
  theme_void()

symbol_female <- ggplot() +
  annotate("text", x = 0.5, y = 0.45, label = "\u2640", size = 8,
    fontface = "bold") +
  theme_void()

# 5) Stack everything with patchwork:
#    Top row = symbols (10% height), bottom = 4×2 grid (90%)
combined_fixed_effects <- (symbol_male | symbol_female) /
  ((pA_I  | pA_II) /
   (pB_I  | pB_II) /
   (pC_I  | pC_II) /
   (pD_I  | pD_II)) +
  plot_layout(heights = c(0.1, 0.9)) +
  theme(
    plot.margin   = margin(1,1,1,1)
  )

# 6) Draw it
print(combined_fixed_effects)
```


```{r}
# Save as TIFF
ggsave(
  filename = "output/fig_fixed_effects_by_sex.tiff",
  plot     = combined_fixed_effects,
  device   = "tiff",
  width    = 6,    # inches
  height   = 9,    # inches
  units    = "in",
  dpi      = 300,
  compression = "lzw"
)
```

## Male Random
```{r}
# turn off auto‐tags
auto_tagless <- theme(plot.tag = element_blank())

# helper to position tags top‐left
tag_style <- theme(
  plot.tag.position = c(0.02, 0.98),
  plot.tag          = element_text(size = 8, face = "bold", hjust = 0, vjust = 1)
)

# blank out all x‐axis elements
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)
# blank y for slope panels
blank_y <- theme(
  axis.title.y = element_blank(),
  axis.text.y  = element_blank(),
  axis.ticks.y = element_blank()
)

# Row 1: Stature (male)
m1_int <- p_random_intercepts_male_stature_z +
  labs(tag = "A I", y = NULL) +
  blank_x + blank_y + tag_style
m1_slope <- p_random_slopes_male_stature_z +
  labs(tag = "A II") +
  blank_x + blank_y + tag_style

# Row 2: Body Mass (male)
m2_int <- p_random_intercepts_male_bodymass_z +
  labs(tag = "B I", y = NULL) +
  blank_x + blank_y + tag_style
m2_slope <- p_random_slopes_male_bodymass_z +
  labs(tag = "B II") +
  blank_x + blank_y + tag_style

# Row 3: Rel. Sitting Ht (male)
m3_int <- p_random_intercepts_male_r_sittinght_z +
  labs(tag = "C I", y = NULL) +
  blank_x + blank_y + tag_style
m3_slope <- p_random_slopes_male_r_sittinght_z +
  labs(tag = "C II") +
  blank_x + blank_y + tag_style

# Row 4: Rel. Body Breadth (male)
m4_int <- p_random_intercepts_male_rbb_z +
  labs(tag = "D I", y = NULL) +
  blank_x + blank_y + tag_style
m4_slope <- p_random_slopes_male_rbb_z +
  labs(tag = "D II") +
  blank_x + tag_style

# combine into a 2‑col × 4‑row grid
combined_random_male <- (
     (m1_int   | m1_slope) /
     (m2_int   | m2_slope) /
     (m3_int   | m3_slope) /
     (m4_int   | m4_slope)
) +
  plot_layout(ncol = 1, heights = rep(1, 4)) +
  plot_annotation(
    title    = "Male Random Effects by Trait",
    subtitle = "Rows (A–D): A = Stature; B = Body mass; C = Relative sitting height; D = Relative body breadth.\nColumns (I, II): I = random intercept; II = random slope for Time (Late vs Early)."
  ) &
  theme_minimal(base_size = 11) &
  theme(
    plot.title    = element_text(size = 11, face = "bold"),
    plot.tag       = element_text(size = 11, face = "bold"),  # override
    plot.subtitle = element_text(size = 11),
    panel.spacing = unit(0.01, "lines"),
    axis.title.x  = element_blank(),
    axis.text.x   = element_text(size = 11),
    axis.text.y   = element_text(size = 11),
    axis.ticks.x  = element_blank()
  )

# render
print(combined_random_male)

```

## Female random
```{r}
# blank out all x‐axis elements
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)
# blank y for slope panels
blank_y <- theme(
  axis.title.y = element_blank(),
  axis.text.y  = element_blank(),
  axis.ticks.y = element_blank()
)

# Row 1: Stature (female)
f1_int <- p_random_intercepts_female_stature_z +
  labs(tag = "A I", y = NULL) +
  blank_x + blank_y + tag_style
f1_slope <- p_random_slopes_female_stature_z +
  labs(tag = "A II") +
  blank_x + blank_y + tag_style

# Row 2: Body Mass (female)
f2_int <- p_random_intercepts_female_bodymass_z +
  labs(tag = "B I", y = NULL) +
  blank_x + blank_y + tag_style
f2_slope <- p_random_slopes_female_bodymass_z +
  labs(tag = "B II") +
  blank_x + blank_y + tag_style

# Row 3: Rel. Sitting Ht (female)
f3_int <- p_random_intercepts_female_r_sittinght_z +
  labs(tag = "C I", y = NULL) +
  blank_x + blank_y + tag_style
f3_slope <- p_random_slopes_female_r_sittinght_z +
  labs(tag = "C II") +
  blank_x + blank_y + tag_style

# Row 4: Rel. Body Breadth (female)
f4_int <- p_random_intercepts_female_rbb_z +
  labs(tag = "D I", y = NULL) +
  blank_x + blank_y + tag_style
f4_slope <- p_random_slopes_female_rbb_z +
  labs(tag = "D II") +
  blank_x + tag_style

# combine into a 2‑col × 4‑row grid
combined_random_female <- (
     (f1_int   | f1_slope) /
     (f2_int   | f2_slope) /
     (f3_int   | f3_slope) /
     (f4_int   | f4_slope)
) +
  plot_layout(ncol = 1, heights = rep(1, 4)) +
  plot_annotation(
    title    = "Female Random Effects by Trait",
    subtitle = "Rows (A–D): A = Stature; B = Body mass; C = Relative sitting height; D = Relative body breadth.\nColumns (I, II): I = random intercept; II = random slope for Time (Late vs Early)."
  ) &
  theme_minimal(base_size = 14) &
  theme(
    plot.title    = element_text(size = 12, face = "bold"),
    plot.tag       = element_text(size = 12, face = "bold"),  # override
    plot.subtitle = element_text(size = 12),
    panel.spacing = unit(0.01, "lines"),
    axis.title.x  = element_blank(),
    axis.text.x   = element_text(size = 11),
    axis.text.y   = element_text(size = 11),
    axis.ticks.x  = element_blank()
  )

# render
print(combined_random_female)
```
## Combined random intercepts
```{r}
# turn off auto‐tags
auto_tagless <- theme(plot.tag = element_blank())

# helper to position tags top‐left
tag_style <- theme(
  plot.tag.position = c(-1, 0.98),
  plot.tag          = element_text(size = 8, face = "bold", hjust = 0, vjust = 1)
)

# blank out all x‐axis elements
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)
# blank y for slope panels
blank_y <- theme(
  axis.title.y = element_blank(),
  axis.text.y  = element_blank(),
  axis.ticks.y = element_blank()
)
# 1) Compute the global intercept range across both sexes and all traits
all_ints <- c(
  raneff_male_stature_z[, random_intercept_male_stature_z],
  raneff_female_stature_z[, random_intercept_female_stature_z],
  raneff_male_bodymass_z[, random_intercept_male_bodymass_z],
  raneff_female_bodymass_z[, random_intercept_female_bodymass_z],
  raneff_male_r_sittinght_z[, random_intercept_male_r_sittinght_z],
  raneff_female_r_sittinght_z[, random_intercept_female_r_sittinght_z],
  raneff_male_rbb_z[, random_intercept_male_rbb_z],
  raneff_female_rbb_z[, random_intercept_female_rbb_z]
)

global_limits <- range(all_ints, na.rm = TRUE)
pad <- diff(global_limits) * 0.05
xlims <- global_limits + c(-pad, pad)
# blank out all x‐axis elements
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)
# blank y for slope panels
blank_y <- theme(
  axis.title.y = element_blank(),
  axis.text.y  = element_blank(),
  axis.ticks.y = element_blank()
)
# 2) Then for each panel, add the same scale:
common_scale <- scale_x_continuous(limits = xlims)

# Row 1: Stature
m1_int <- p_random_intercepts_male_stature_z +
  common_scale + ylab("Stature") + blank_x + tag_style
f1_int <- p_random_intercepts_female_stature_z +
  common_scale + blank_x + tag_style +
  scale_y_discrete(labels = NULL)

# Row 2: Body Mass
m2_int <- p_random_intercepts_male_bodymass_z +
  common_scale + ylab("Body Mass") + blank_x + tag_style
f2_int <- p_random_intercepts_female_bodymass_z +
  common_scale  + blank_x + tag_style+
  scale_y_discrete(labels = NULL)

# Row 3: Rel. Sitting Ht
m3_int <- p_random_intercepts_male_r_sittinght_z +
  common_scale + ylab("Rel. Sitting Height") + blank_x + tag_style
f3_int <- p_random_intercepts_female_r_sittinght_z +
  common_scale + blank_x + tag_style+
  scale_y_discrete(labels = NULL)

# Row 4: Rel. Body Breadth
m4_int <- p_random_intercepts_male_rbb_z +
  common_scale + ylab("Rel. Body Breadth") + blank_x + tag_style
f4_int <- p_random_intercepts_female_rbb_z +
  common_scale + blank_x + tag_style+
  scale_y_discrete(labels = NULL)

# 3) Stack into one column
combined_random_intercept <- (
     m1_int /
     f1_int /
     m2_int /
     f2_int /
     m3_int /
     f3_int /
     m4_int /
     f4_int
) +
  plot_layout(ncol   = 2,
              heights= rep(1, 4)) +
 theme_minimal(base_size = 12) &
  theme(
    plot.title    = element_text(size = 12, face = "bold"),
    plot.subtitle = element_text(size = 12),
    plot.tag       = element_text(size = 12, face = "bold"),  # override
    plot.tag.position = c(0.02, 0.98),
    panel.spacing = unit(0.2, "lines"),
    axis.title.x  = element_blank(),
    axis.text.x   = element_text(size = 11),
    axis.text.y   = element_text(size = 11, color = "black"),
    axis.ticks.x  = element_line()
  )

print(combined_random_intercept)
```

```{r}
ggsave(
  "output/fig_random_intercepts.tiff",
  combined_random_intercept,
  device      = "tiff",
  width       = 9,
  height      = 9,
  units       = "in",
  dpi         = 300,
  compression = "lzw"
)
```

## Combined random slopes
```{r}
# 1) Compute the global slope range across both sexes & all traits
all_slopes <- c(
  raneff_male_stature_z[, random_slope_male_stature_z],
  raneff_female_stature_z[, random_slope_female_stature_z],
  raneff_male_bodymass_z[, random_slope_male_bodymass_z],
  raneff_female_bodymass_z[, random_slope_female_bodymass_z],
  raneff_male_r_sittinght_z[, random_slope_male_r_sittinght_z],
  raneff_female_r_sittinght_z[, random_slope_female_r_sittinght_z],
  raneff_male_rbb_z[, random_slope_male_rbb_z],
  raneff_female_rbb_z[, random_slope_female_rbb_z]
)
global_slope_limits <- range(all_slopes, na.rm = TRUE)
pad_slope <- diff(global_slope_limits) * 0.05
xlims_slope <- global_slope_limits + c(-pad_slope, pad_slope)
common_slope_scale <- scale_x_continuous(limits = xlims_slope)

# 2) Re‐use your blank‐axis & tag styles
blank_x <- theme(
  axis.title.x = element_blank(),
  axis.text.x  = element_blank(),
  axis.ticks.x = element_blank()
)
blank_y_female <- theme(
  axis.title.y = element_blank(),
  axis.text.y  = element_blank(),
  axis.ticks.y = element_blank()
)
tag_style <- theme(
  plot.tag.position = c(0.02, 0.98),
  plot.tag          = element_text(size = 8, face = "bold", hjust = 0, vjust = 1)
)

# 3) Build each of the eight slope‐panels

# Row 1: Stature slopes
m1_slope <- p_random_slopes_male_stature_z +
  common_slope_scale +
  ylab("Stature") +
  blank_x + tag_style
f1_slope <- p_random_slopes_female_stature_z +
  common_slope_scale +
  blank_x + blank_y_female + tag_style+
  scale_y_discrete(labels = NULL)

# Row 2: Body Mass slopes
m2_slope <- p_random_slopes_male_bodymass_z +
  common_slope_scale +
  ylab("Body Mass") +
  blank_x + tag_style
f2_slope <- p_random_slopes_female_bodymass_z +
  common_slope_scale +
  blank_x + blank_y_female + tag_style+
  scale_y_discrete(labels = NULL)

# Row 3: Rel. Sitting Ht slopes
m3_slope <- p_random_slopes_male_r_sittinght_z +
  common_slope_scale +
  ylab("Rel. Sitting Height") +
  blank_x + tag_style
f3_slope <- p_random_slopes_female_r_sittinght_z +
  common_slope_scale +
  blank_x + blank_y_female + tag_style+
  scale_y_discrete(labels = NULL)

# Row 4: Rel. Body Breadth slopes
m4_slope <- p_random_slopes_male_rbb_z +
  common_slope_scale +
  ylab("Rel. Body Breadth") +
  blank_x + tag_style
f4_slope <- p_random_slopes_female_rbb_z +
  common_slope_scale +
  blank_x + blank_y_female + tag_style+
  scale_y_discrete(labels = NULL)

# 4) Stack into a 2‑col × 4‑row grid
combined_random_slope <- (
     (m1_slope | f1_slope) /
     (m2_slope | f2_slope) /
     (m3_slope | f3_slope) /
     (m4_slope | f4_slope)
) +
  plot_layout(ncol   = 1,
              heights= rep(1, 4)) +
 theme_minimal(base_size = 12) &
  theme(
    plot.title    = element_text(size = 12, face = "bold"),
    plot.subtitle = element_text(size = 12),
    plot.tag       = element_text(size = 12, face = "bold"),  # override
    plot.tag.position = c(0.02, 0.98),
    panel.spacing = unit(0.2, "lines"),
    axis.title.x  = element_blank(),
    axis.text.x   = element_text(size = 11),
    axis.text.y   = element_text(size = 11, color = "black"),
    axis.ticks.x  = element_line()
  )

# 5) Render
print(combined_random_slope)
```

```{r}
ggsave(
  "output/fig_random_slopes.tiff",
  combined_random_slope,
  device      = "tiff",
  width       = 9,
  height      = 9,
  units       = "in",
  dpi         = 300,
  compression = "lzw"
)
```

## Preditive Map
### Ealry Rural
#### Male
```{r,warning=FALSE}
p_male_stature_comparison_z_early_rural <- p_male_stature_comparison_z_early_rural +
  ylab("Stature")

p_models_z_male_bodymass_early_rural <- p_models_z_male_bodymass_early_rural +
  ylab("Body Mass")

p_models_z_male_rsh_early_rural <- p_models_z_male_rsh_early_rural +
  ylab("Rel. Sitting Height")

p_models_z_male_rbb_early_rural <- p_models_z_male_rbb_early_rural +
  ylab("Rel. Body Breadth")

combined_plot_male_clean_early_rural <- (p_male_stature_comparison_z_early_rural +
                             p_models_z_male_bodymass_early_rural +
                             p_models_z_male_rsh_early_rural) +
  plot_layout(
    ncol    = 1,               # still one column
    heights = rep(1, 1),       # four equal rows now
    guides  = "collect"        # gather all legends into one
  )&
  theme(
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_blank(),
    axis.ticks   = element_blank(),  # (optional) remove ticks too
    plot.title   = element_blank(),   # remove small titles,  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7) # y-axis tick labels
  )


combined_male_map_early_rural <- (combined_plot_male_clean_early_rural +
                      p_models_z_male_rbb_early_rural) +
  plot_layout(ncol = 1, heights = rep(1, 1), 
              guides = "collect") +
    theme(
    legend.position = "right",  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7), # y-axis tick labels
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_text(size = 7) # x-axis tick labels
    )

# Print the final plot
print(combined_male_map_early_rural)
```

```{r}
# Save the plot
ggsave("output/combined_male_map_early_rural.tiff", combined_male_map_early_rural, 
       width = 5.6, height = 6.2, dpi = 600, 
       device = "tiff", compression = "lzw")
```

#### Female
```{r,warning=FALSE}
p_female_stature_comparison_z_early_rural <- p_female_stature_comparison_z_early_rural +
  ylab("Stature")

p_models_z_female_bodymass_early_rural <- p_models_z_female_bodymass_early_rural +
  ylab("Body Mass")

p_models_z_female_rsh_early_rural <- p_models_z_female_rsh_early_rural +
  ylab("Rel. Sitting Height")

p_models_z_female_rbb_early_rural <- p_models_z_female_rbb_early_rural +
  ylab("Rel. Body Breadth")

combined_plot_female_clean_early_rural <- (p_female_stature_comparison_z_early_rural +
                             p_models_z_female_bodymass_early_rural +
                             p_models_z_female_rsh_early_rural) +
  plot_layout(
    ncol    = 1,               # still one column
    heights = rep(1, 1),       # four equal rows now
    guides  = "collect"        # gather all legends into one
  )&
  theme(
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_blank(),
    axis.ticks   = element_blank(),  # (optional) remove ticks too
    plot.title   = element_blank(),   # remove small titles,  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7) # y-axis tick labels
  )


combined_female_map_early_rural <- (combined_plot_female_clean_early_rural +
                      p_models_z_female_rbb_early_rural) +
  plot_layout(ncol = 1, heights = rep(1, 1), 
              guides = "collect") +
    theme(
    legend.position = "right",  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7), # y-axis tick labels
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_text(size = 7) # x-axis tick labels
      )

# Print the final plot
print(combined_female_map_early_rural)
```
```{r}
# Save the plot
ggsave("output/combined_female_map_early_rural.tiff", combined_female_map_early_rural, 
       width = 5.6, height = 6.2, dpi = 600, 
       device = "tiff", compression = "lzw")
```

### Late Urban
#### Male
```{r,warning=FALSE}
p_male_stature_comparison_z_late_urban <- p_male_stature_comparison_z_late_urban +
  ylab("Stature")

p_models_z_male_bodymass_late_urban <- p_models_z_male_bodymass_late_urban +
  ylab("Body Mass")

p_models_z_male_rsh_late_urban <- p_models_z_male_rsh_late_urban +
  ylab("Rel. Sitting Height")

p_models_z_male_rbb_late_urban <- p_models_z_male_rbb_late_urban +
  ylab("Rel. Body Breadth")

combined_plot_male_clean_late_urban <- (p_male_stature_comparison_z_late_urban +
                             p_models_z_male_bodymass_late_urban +
                             p_models_z_male_rsh_late_urban) +
  plot_layout(
    ncol    = 1,               # still one column
    heights = rep(1, 1),       # four equal rows now
    guides  = "collect"        # gather all legends into one
  )&
  theme(
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_blank(),
    axis.ticks   = element_blank(),  # (optional) remove ticks too
    plot.title   = element_blank(),   # remove small titles,  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7) # y-axis tick labels
  )


combined_male_map_late_urban <- (combined_plot_male_clean_late_urban +
                      p_models_z_male_rbb_late_urban) +
  plot_layout(ncol = 1, heights = rep(1, 1), 
              guides = "collect") +
    theme(
    legend.position = "right",  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7), # y-axis tick labels
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_text(size = 7) # x-axis tick labels
      )

# Print the final plot
print(combined_male_map_late_urban)
```

```{r}
# Save the plot
ggsave("output/combined_male_map_late_urban.tiff", combined_male_map_late_urban, 
       width = 5.6, height = 6.2, dpi = 600, 
       device = "tiff", compression = "lzw")
```
#### Female
```{r,warning=FALSE}
p_female_stature_comparison_z_late_urban <- p_female_stature_comparison_z_late_urban +
  ylab("Stature")

p_models_z_female_bodymass_late_urban <- p_models_z_female_bodymass_late_urban +
  ylab("Body Mass")

p_models_z_female_rsh_late_urban <- p_models_z_female_rsh_late_urban +
  ylab("Rel. Sitting Height")

p_models_z_female_rbb_late_urban <- p_models_z_female_rbb_late_urban +
  ylab("Rel. Body Breadth")
combined_plot_female_clean_late_urban <- (p_female_stature_comparison_z_late_urban +
                             p_models_z_female_bodymass_late_urban +
                             p_models_z_female_rsh_late_urban) +
  plot_layout(
    ncol    = 1,               # still one column
    heights = rep(1, 1),       # four equal rows now
    guides  = "collect"        # gather all legends into one
  )&
  theme(
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_blank(),
    axis.ticks   = element_blank(),  # (optional) remove ticks too
    plot.title   = element_blank(),   # remove small titles,  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7) # y-axis tick labels
  )


combined_female_map_late_urban <- (combined_plot_female_clean_late_urban +
                      p_models_z_female_rbb_late_urban) +
  plot_layout(ncol = 1, heights = rep(1, 1), 
              guides = "collect") +
    theme(
    legend.position = "right",  
    legend.key.size = unit(0.6, "lines"),  # <<< reduce symbol size
    legend.text = element_text(size = 7),
    legend.title = element_text(size = 7, face = "bold"),
    axis.title.y = element_text(size = 7, face = "bold"),  # y-axis title size
    axis.text.y  = element_text(size = 7), # y-axis tick labels
    axis.title.x = element_blank(),  # Correct naming
    axis.text.x  = element_text(size = 7) # x-axis tick labels
      )

# Print the final plot
print(combined_female_map_late_urban)
```

```{r}
# Save the plot
ggsave("output/combined_female_map_late_urban.tiff", combined_female_map_late_urban, 
       width = 5.6, height = 6.2, dpi = 600, 
       device = "tiff", compression = "lzw")
```


# Before the model trend
```{r}
trend_colors <- c(Male = "#1f77b4", Female = "#d62728")
```

## Stature Trend
```{r,warning=FALSE}
# 1) summarize each sex and add Sex in one go
plot_male <- modern_male_stature %>%
  group_by(Langsubgroup, Time, Urbanism) %>%
  summarize(
    mean_stature = mean(Stature, na.rm = TRUE),
    sd_stature   = sd(Stature,   na.rm = TRUE),
    n            = n(),
    .groups = "drop"
  ) %>%
  mutate(
    se       = sd_stature / sqrt(n),
    lower_ci = mean_stature - 1.96 * se,
    upper_ci = mean_stature + 1.96 * se,
    Sex      = "Male"
  )

plot_female <- modern_female_stature %>%
  group_by(Langsubgroup, Time, Urbanism) %>%
  summarize(
    mean_stature = mean(Stature, na.rm = TRUE),
    sd_stature   = sd(Stature,   na.rm = TRUE),
    n            = n(),
    .groups = "drop"
  ) %>%
  mutate(
    se       = sd_stature / sqrt(n),
    lower_ci = mean_stature - 1.96 * se,
    upper_ci = mean_stature + 1.96 * se,
    Sex      = "Female"
  )

# 2) bind once, filter out unwanted Urbanism, drop tiny groups
combined <- bind_rows(plot_male, plot_female) %>%
  filter(
    Urbanism != "an",
    !grepl("-", Urbanism),
    n > 1                   # drop single‐case groups if you want
  )

# 3) reorder facets by overall mean
combined <- combined %>%
  group_by(Langsubgroup) %>%
  mutate(overall_mean = mean(mean_stature, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(
    Langsubgroup = fct_reorder(Langsubgroup, overall_mean, .desc = TRUE)
  )

# 4) compute y‐limits safely
y_min <- min(combined$lower_ci, na.rm = TRUE)
y_max <- max(combined$upper_ci, na.rm = TRUE)

# 5) plot
p_stature <- ggplot(combined, 
       aes(x = Time, 
           y = mean_stature,
           group = interaction(Sex, Urbanism),
           color = Sex, 
           linetype = Urbanism,   # now Urban = dashed, Rural = solid
           shape    = Urbanism)) + # now Urban = triangle, Rural = circle
  geom_line(size = 0.3) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.1) +
  facet_wrap(~ Langsubgroup, ncol = 3, labeller = label_wrap_gen(width = 12)) +
  scale_color_manual(values     = trend_colors) +
  scale_linetype_manual(values = c(Urban = "dashed", Rural = "solid")) +
  scale_shape_manual(  values = c(Urban = 17,      Rural = 16)) +
  scale_y_continuous(limits = c(y_min, y_max)) +
  labs(
    x        = "Time Period",
    y        = "Mean Stature (cm)",
    color    = NULL,
    linetype = NULL,
    shape    = NULL
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    legend.position = "bottom"
  )

p_stature
```


```{r}
# Save as TIFF
ggsave(
  filename = "output/mean_stature_trend.tiff",
  plot     = p_stature,
  device   = "tiff",
  dpi      = 300,
  width    = 6,
  height   =4,
  units    = "in"
)
```


## Bodymass Trend
```{r,warning=FALSE}
# Compute mean stature and confidence intervals (95% CI)
plot_male_bodymass <- modern_male_bodymass %>%
  group_by(Langsubgroup , Time, Urbanism) %>%
  summarise(
    mean_bodymass = mean(Bodymass, na.rm = TRUE),
    sd_bodymass = sd(Bodymass, na.rm = TRUE),
    n = n(),  # Sample size
    se = sd_bodymass / sqrt(n),  # Standard error
    lower_ci = mean_bodymass - 1.96 * se,  # 95% CI lower
    upper_ci = mean_bodymass + 1.96 * se   # 95% CI upper
  ) %>%
  ungroup()

# Compute mean bodymass and confidence intervals (95% CI)
plot_female_bodymass <- modern_female_bodymass %>%
  group_by(Langsubgroup , Time, Urbanism) %>%
  summarise(
    mean_bodymass = mean(Bodymass, na.rm = TRUE),
    sd_bodymass = sd(Bodymass, na.rm = TRUE),
    n = n(),  # Sample size
    se = sd_bodymass / sqrt(n),  # Standard error
    lower_ci = mean_bodymass - 1.96 * se,  # 95% CI lower
    upper_ci = mean_bodymass + 1.96 * se   # 95% CI upper
  ) %>%
  ungroup()
combined_bodymass <- bind_rows(plot_male_bodymass, plot_female_bodymass)

# Add a Gender column to each dataset
plot_male_bodymass <- plot_male_bodymass %>% mutate(Sex = "Male")
plot_female_bodymass <- plot_female_bodymass %>% mutate(Sex = "Female")

# Combine datasets
combined_bodymass <- bind_rows(plot_male_bodymass, plot_female_bodymass)

# Remove rows where Urbanism equals "an" or contains a dash "-"
combined_bodymass <- combined_bodymass %>% 
  filter(!grepl("-", Urbanism))

# Reorder Lang_subgroup facets based on overall mean bodymass (tallest first)
combined_bodymass <- combined_bodymass %>%
  group_by(Langsubgroup) %>%
  mutate(overall_mean = mean(mean_bodymass, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Langsubgroup = reorder(Langsubgroup, -overall_mean))

# Determine overall y-axis limits from confidence intervals
y_min <- min(combined_bodymass$lower_ci, na.rm = TRUE)
y_max <- max(combined_bodymass$upper_ci, na.rm = TRUE)

#High to Low
combined_bodymass <- combined_bodymass %>%
  group_by(Langsubgroup) %>%
  mutate(overall_mean = mean(mean_bodymass, na.rm = TRUE)) %>%
  ungroup() %>%
  # HIGH → LOW: note the minus sign
  mutate(Langsubgroup = reorder(Langsubgroup, -overall_mean))
```


```{r, warning=FALSE}
p_bodymass <- ggplot(combined_bodymass, 
       aes(x = Time, 
           y = mean_bodymass,
           group = interaction(Sex, Urbanism),
           color    = Sex, 
           linetype = Urbanism,
           shape    = Urbanism)) +
  geom_line(size = 0.3) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.1) +
  facet_wrap(~ Langsubgroup, ncol = 3, labeller = label_wrap_gen(width = 12)) +
  scale_color_manual(values     = trend_colors) +
  scale_linetype_manual(values = c(Urban = "dashed", Rural = "solid")) +
  scale_shape_manual(  values = c(Urban = 17,      Rural = 16)) +
  scale_y_continuous(limits = c(y_min, y_max)) +
  labs(
    x        = "Time Period",
    y        = "Mean Body Mass (kg)",
    color    = NULL,
    linetype = NULL,
    shape    = NULL
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    legend.position = "bottom"
  )
p_bodymass
```
```{r}
ggsave(
  filename = "output/mean_bodymass_trend.tiff",
  plot     = p_bodymass,
  device   = "tiff",
  dpi      = 300,
  width    = 6,
  height   = 4,
  units    = "in"
)

```

## Relative Sitting Height Trend
```{r,warning=FALSE}
# Compute mean RSH and confidence intervals
plot_male_rsh <- modern_male_r_sittinght %>%
  group_by(Langsubgroup , Time, Urbanism) %>%
  summarise(
    mean_rsh = mean(RSittinght, na.rm = TRUE),
    sd_rsh   = sd(RSittinght, na.rm = TRUE),
    n        = n(),
    se       = sd_rsh / sqrt(n),
    lower_ci = mean_rsh - 1.96 * se,
    upper_ci = mean_rsh + 1.96 * se
  ) %>%
  ungroup() %>%
  mutate(Sex = "Male")

plot_female_rsh <- modern_female_r_sittinght %>%
  group_by(Langsubgroup , Time, Urbanism) %>%
  summarise(
    mean_rsh = mean(RSittinght, na.rm = TRUE),
    sd_rsh   = sd(RSittinght, na.rm = TRUE),
    n        = n(),
    se       = sd_rsh / sqrt(n),
    lower_ci = mean_rsh - 1.96 * se,
    upper_ci = mean_rsh + 1.96 * se
  ) %>%
  ungroup() %>%
  mutate(Sex = "Female")

# Combine and clean
combined_rsh <- bind_rows(plot_male_rsh, plot_female_rsh) %>%
  filter(Urbanism != "an", !grepl("-", Urbanism)) %>%
  group_by(Langsubgroup) %>%
  mutate(overall_mean = mean(mean_rsh, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Langsubgroup = reorder(Langsubgroup, -overall_mean))

# Axis limits
y_min <- min(combined_rsh$lower_ci, na.rm = TRUE)
y_max <- max(combined_rsh$upper_ci, na.rm = TRUE)

# Plot
# Build & assign
p_rsh <- ggplot(combined_rsh, 
       aes(x = Time, 
           y = mean_rsh,
           group = interaction(Sex, Urbanism),
           color = Sex, 
           linetype = Urbanism,
           shape    = Urbanism)) +
  geom_line(size = 0.3) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.1) +
  facet_wrap(~ Langsubgroup, ncol = 3, labeller = label_wrap_gen(width = 12)) +
  scale_color_manual(values     = trend_colors) +
  scale_linetype_manual(values = c(Urban = "dashed", Rural = "solid")) +
  scale_shape_manual(  values = c(Urban = 17,      Rural = 16)) +
  scale_y_continuous(limits = c(y_min, y_max)) +
  labs(
    x        = "Time Period",
    y        = "Mean Relative Sitting Height",
    color    = NULL,
    linetype = NULL,
    shape    = NULL
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    legend.position = "bottom"
  )
p_rsh
```


```{r,warning=FALSE}
ggsave(
  filename = "output/mean_relative_sitting_height_trend.tiff",
  plot     = p_rsh,
  device   = "tiff",
  dpi      = 300,
  width    = 6,
  height   = 4,
  units    = "in"
)
```

## Relative Body Breadth Trend
```{r,warning=FALSE}
# 1) Compute mean RBB and confidence intervals for males
plot_male_rbb <- modern_male_rbb %>%
  group_by(Langsubgroup, Time, Urbanism) %>%
  summarise(
    mean_rbb = mean(RelativeBodyBreadth, na.rm = TRUE),
    sd_rbb   = sd(RelativeBodyBreadth, na.rm = TRUE),
    n        = n(),
    se       = sd_rbb / sqrt(n),
    lower_ci = mean_rbb - 1.96 * se,
    upper_ci = mean_rbb + 1.96 * se
  ) %>%
  ungroup() %>%
  mutate(Sex = "Male")

# 2) Compute mean RBB and confidence intervals for females
plot_female_rbb <- modern_female_rbb %>%
  group_by(Langsubgroup, Time, Urbanism) %>%
  summarise(
    mean_rbb = mean(RelativeBodyBreadth, na.rm = TRUE),
    sd_rbb   = sd(RelativeBodyBreadth, na.rm = TRUE),
    n        = n(),
    se       = sd_rbb / sqrt(n),
    lower_ci = mean_rbb - 1.96 * se,
    upper_ci = mean_rbb + 1.96 * se
  ) %>%
  ungroup() %>%
  mutate(Sex = "Female")

# 3) Combine male and female data
combined_rbb <- bind_rows(plot_male_rbb, plot_female_rbb)

# 4) Clean Urbanism: remove rows with "-" or "an" if needed
combined_rbb <- combined_rbb %>%
  filter(Urbanism != "an", !grepl("-", Urbanism))

# 5) Order Langsubgroup facets by overall mean RBB (high → low)
combined_rbb <- combined_rbb %>%
  group_by(Langsubgroup) %>%
  mutate(overall_mean = mean(mean_rbb, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(Langsubgroup = reorder(Langsubgroup, -overall_mean))

# 6) Determine y-axis limits based on CIs
y_min_rbb <- min(combined_rbb$lower_ci, na.rm = TRUE)
y_max_rbb <- max(combined_rbb$upper_ci, na.rm = TRUE)

# 7) Plot
p_rbb <- ggplot(combined_rbb, 
       aes(x = Time, 
           y = mean_rbb,
           group = interaction(Sex, Urbanism),
           color    = Sex, 
           linetype = Urbanism,
           shape    = Urbanism)) +
  geom_line(size = 0.3) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci), width = 0.1) +
  facet_wrap(~ Langsubgroup, ncol = 3, labeller = label_wrap_gen(width = 12)) +
  scale_color_manual(values     = trend_colors) +
  scale_linetype_manual(values = c(Urban = "dashed", Rural = "solid")) +
  scale_shape_manual(  values = c(Urban = 17,      Rural = 16)) +
  scale_y_continuous(limits = c(y_min_rbb, y_max_rbb)) +
  labs(
    x        = "Time Period",
    y        = "Mean Relative Body Breadth",
    color    = NULL,
    linetype = NULL,
    shape    = NULL
  ) +
  theme_minimal() +
  theme(
    strip.text      = element_text(face = "bold"),
    legend.position = "bottom"
  )
p_rbb
```

```{r,warning=FALSE}
ggsave(
  filename = "output/mean_relative_body_breadth_trend.tiff",
  plot     = p_rbb,
  device   = "tiff",
  dpi      = 300,
  width    = 6,
  height   = 4,
  units    = "in"
)
```

# Compute the ICC (intraclass correlation coefficient)
```{r}
# Helper function to compute ICC from posterior draws
compute_icc_from_draws <- function(post_draws) {
  # Extract random effects parameters
  sd_int <- post_draws$`sd_Langsubgroup__Intercept`
  sd_time <- post_draws$`sd_Langsubgroup__TimeLate`
  cor_int_time <- post_draws$`cor_Langsubgroup__Intercept__TimeLate`
  
  # Compute variance components
  var_int <- sd_int^2
  var_time <- sd_time^2
  cov_int_time <- cor_int_time * sd_int * sd_time
  
  # Compute residual variance for Student‑t likelihood (valid when nu > 2)
  sigma <- post_draws$sigma
  nu <- post_draws$nu
  resid_var <- sigma^2 * nu / (nu - 2)
  
  # Compute group-level variance at two time points:
  # For Time = 0 (Early): variance is just the intercept variance.
  group_var_early <- var_int
  # For Time = 1 (Late): variance includes the slope and its covariance with the intercept.
  group_var_late <- var_int + 2 * cov_int_time + var_time
  
  # Compute ICC for each posterior draw at each time point
  icc_early <- group_var_early / (group_var_early + resid_var)
  icc_late <- group_var_late / (group_var_late + resid_var)
  
  list(icc_early = icc_early, icc_late = icc_late)
}

# Helper function to print ICC summary
print_icc_summary <- function(icc_list, metric, gender) {
  cat("ICC for", gender, metric, "(Time = 'Early'):\n")
  cat("  Mean ICC:", mean(icc_list$icc_early), "\n")
  cat("  95% Credible Interval:", quantile(icc_list$icc_early, probs = c(0.025, 0.975)), "\n\n")
  
  cat("ICC for", gender, metric, "(Time = 'Late'):\n")
  cat("  Mean ICC:", mean(icc_list$icc_late), "\n")
  cat("  95% Credible Interval:", quantile(icc_list$icc_late, probs = c(0.025, 0.975)), "\n\n")
}

# ----- Male Metrics -----

# Male Stature
post_draws_male_stature <- as_draws_df(fit_modern_male_stature_z)
icc_male_stature <- compute_icc_from_draws(post_draws_male_stature)

# Male Body Mass
post_draws_male_bodymass <- as_draws_df(fit_modern_male_bodymass_scaled)
icc_male_bodymass <- compute_icc_from_draws(post_draws_male_bodymass)

# Male Relative Sitting Height
post_draws_male_rel_sit <- as_draws_df(fit_modern_male_r_sittinght_scaled)
icc_male_rel_sit <- compute_icc_from_draws(post_draws_male_rel_sit)

# Male Relative Body Breadth
post_draws_male_rel_bb <- as_draws_df(fit_modern_male_relativebodybreadth_scaled)
icc_male_rel_bb <- compute_icc_from_draws(post_draws_male_rel_bb)

# ----- Female Metrics -----

# Female Stature
post_draws_female_stature <- as_draws_df(fit_modern_female_stature_altitude_abs_z)
icc_female_stature <- compute_icc_from_draws(post_draws_female_stature)

# Female Body Mass
post_draws_female_bodymass <- as_draws_df(fit_modern_female_bodymass_scaled)
icc_female_bodymass <- compute_icc_from_draws(post_draws_female_bodymass)

# Female Relative Sitting Height
post_draws_female_rel_sit <- as_draws_df(fit_modern_female_r_sittinght_scaled)
icc_female_rel_sit <- compute_icc_from_draws(post_draws_female_rel_sit)

# Female Relative Body Breadth
post_draws_female_rel_bb <- as_draws_df(fit_modern_female_relativebodybreadth_scaled)
icc_female_rel_bb <- compute_icc_from_draws(post_draws_female_rel_bb)

# ----- Print Summary of ICC Results -----

cat("==== Male Metrics ====\n")
print_icc_summary(icc_male_stature, "Stature", "Male")
print_icc_summary(icc_male_bodymass, "Body Mass", "Male")
print_icc_summary(icc_male_rel_sit, "Relative Sitting Height", "Male")
print_icc_summary(icc_male_rel_bb, "Relative Body Breadth", "Male")

cat("==== Female Metrics ====\n")
print_icc_summary(icc_female_stature, "Stature", "Female")
print_icc_summary(icc_female_bodymass, "Body Mass", "Female")
print_icc_summary(icc_female_rel_sit, "Relative Sitting Height", "Female")
print_icc_summary(icc_female_rel_bb, "Relative Body Breadth", "Female")

```



